"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[317],{8110:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"Features/polls","title":"Polls Feature","description":"Adding polls to the chat app was one of my favorite features to implement. It gives users a way to quickly gather opinions, make decisions, and boost engagement in group conversations.","source":"@site/docs-source/Features/polls.md","sourceDirName":"Features","slug":"/Features/polls","permalink":"/CustomChatApp/docs/Features/polls","draft":false,"unlisted":false,"editUrl":"https://github.com/Emir2099/CustomChatApp/docs-source/Features/polls.md","tags":[],"version":"current","lastUpdatedAt":1747596452000,"sidebarPosition":12,"frontMatter":{"sidebar_position":12},"sidebar":"tutorialSidebar","previous":{"title":"Invite Links","permalink":"/CustomChatApp/docs/Features/invite-links"},"next":{"title":"Announcements Feature","permalink":"/CustomChatApp/docs/Features/announcements"}}');var o=t(4848),l=t(8453);const i={sidebar_position:12},r="Polls Feature",a={},p=[{value:"How Polls Work",id:"how-polls-work",level:2},{value:"Poll Data Structure",id:"poll-data-structure",level:2},{value:"Creating Polls",id:"creating-polls",level:2},{value:"Poll Creation UI",id:"poll-creation-ui",level:2},{value:"Poll Display Component",id:"poll-display-component",level:2},{value:"Voting and Closing Polls",id:"voting-and-closing-polls",level:2},{value:"Integration with MessageInput",id:"integration-with-messageinput",level:2},{value:"Auto-expiring Polls",id:"auto-expiring-polls",level:2},{value:"Technical Challenges",id:"technical-challenges",level:2},{value:"Real-time Updates",id:"real-time-updates",level:3},{value:"Race Conditions",id:"race-conditions",level:3},{value:"UI Design Challenges",id:"ui-design-challenges",level:3},{value:"Future Improvements",id:"future-improvements",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,l.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"polls-feature",children:"Polls Feature"})}),"\n",(0,o.jsx)(e.p,{children:"Adding polls to the chat app was one of my favorite features to implement. It gives users a way to quickly gather opinions, make decisions, and boost engagement in group conversations."}),"\n",(0,o.jsx)(e.h2,{id:"how-polls-work",children:"How Polls Work"}),"\n",(0,o.jsx)(e.p,{children:"The polling system follows this basic flow:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"A user creates a poll with a question and multiple options"}),"\n",(0,o.jsx)(e.li,{children:"The poll appears as a special message in the chat"}),"\n",(0,o.jsx)(e.li,{children:"Other users can vote on their preferred options"}),"\n",(0,o.jsx)(e.li,{children:"Results update in real-time as votes come in"}),"\n",(0,o.jsx)(e.li,{children:"The poll creator can close the poll when they're ready"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"poll-data-structure",children:"Poll Data Structure"}),"\n",(0,o.jsx)(e.p,{children:"I designed a specific data structure for polls within the messages collection:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-json",children:'{\n  "id": "poll-123456",\n  "type": "poll",\n  "sender": "userABC",\n  "senderName": "Jane Doe",\n  "senderPhotoURL": "https://example.com/jane.jpg",\n  "timestamp": 1651234567890,\n  "question": "Where should we go for lunch?",\n  "options": {\n    "option1": { "text": "Pizza Place", "votes": 3 },\n    "option2": { "text": "Burger Joint", "votes": 1 },\n    "option3": { "text": "Salad Bar", "votes": 2 }\n  },\n  "voters": {\n    "user1": "option1",\n    "user2": "option1",\n    "user3": "option2",\n    "user4": "option3",\n    "user5": "option1",\n    "user6": "option3"\n  },\n  "isOpen": true,\n  "expiresAt": 1651321000000\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"creating-polls",children:"Creating Polls"}),"\n",(0,o.jsx)(e.p,{children:"I implemented a poll creation function in the ChatContext:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:"// In ChatContext.jsx\nconst createPoll = async (question, options, expirationMinutes = 1440) => {\n  if (!currentChat?.id || !user?.uid || !question || !options || options.length < 2) {\n    return null;\n  }\n  \n  try {\n    const messageRef = push(ref(db, `messages/${currentChat.id}`));\n    const messageId = messageRef.key;\n    \n    // Format options into the expected structure\n    const optionsObject = {};\n    options.forEach((option, index) => {\n      optionsObject[`option${index + 1}`] = {\n        text: option,\n        votes: 0\n      };\n    });\n    \n    // Calculate expiration time (default to 24 hours)\n    const expiresAt = Date.now() + (expirationMinutes * 60 * 1000);\n    \n    const pollMessage = {\n      id: messageId,\n      type: 'poll',\n      sender: user.uid,\n      senderName: user.displayName,\n      senderPhotoURL: user.photoURL,\n      timestamp: serverTimestamp(),\n      question,\n      options: optionsObject,\n      voters: {},\n      isOpen: true,\n      expiresAt,\n      readBy: {\n        [user.uid]: serverTimestamp()\n      }\n    };\n    \n    await set(messageRef, pollMessage);\n    \n    // Update last message in chat\n    await update(ref(db, `chats/${currentChat.id}`), {\n      lastMessage: {\n        content: `\ud83d\udcca Poll: ${question}`,\n        sender: user.uid,\n        senderName: user.displayName,\n        timestamp: serverTimestamp()\n      },\n      lastMessageTime: serverTimestamp()\n    });\n    \n    return messageId;\n  } catch (error) {\n    console.error('Error creating poll:', error);\n    return null;\n  }\n};\n"})}),"\n",(0,o.jsx)(e.h2,{id:"poll-creation-ui",children:"Poll Creation UI"}),"\n",(0,o.jsx)(e.p,{children:"I built a simple component to let users create polls:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'// src/components/chat/PollCreator.jsx\nimport { useState } from \'react\';\nimport { useChat } from \'../../contexts/ChatContext\';\nimport styles from \'./PollCreator.module.css\';\n\nexport default function PollCreator({ onClose }) {\n  const [question, setQuestion] = useState(\'\');\n  const [options, setOptions] = useState([\'\', \'\']);\n  const [expiration, setExpiration] = useState(\'1440\'); // 24 hours in minutes\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [error, setError] = useState(\'\');\n  \n  const { createPoll } = useChat();\n  \n  const handleAddOption = () => {\n    if (options.length < 10) {\n      setOptions([...options, \'\']);\n    }\n  };\n  \n  const handleRemoveOption = (index) => {\n    if (options.length > 2) {\n      setOptions(options.filter((_, i) => i !== index));\n    }\n  };\n  \n  const handleOptionChange = (index, value) => {\n    const newOptions = [...options];\n    newOptions[index] = value;\n    setOptions(newOptions);\n  };\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    setError(\'\');\n    \n    // Validate inputs\n    if (!question.trim()) {\n      setError(\'Please enter a question\');\n      return;\n    }\n    \n    // Filter out empty options and check if we have at least 2\n    const validOptions = options.filter(opt => opt.trim());\n    if (validOptions.length < 2) {\n      setError(\'Please provide at least 2 options\');\n      return;\n    }\n    \n    setIsSubmitting(true);\n    \n    try {\n      await createPoll(question, validOptions, parseInt(expiration));\n      onClose();\n    } catch (err) {\n      setError(\'Failed to create poll: \' + err.message);\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n  \n  return (\n    <div className={styles.pollCreator}>\n      <h3>Create a Poll</h3>\n      \n      {error && <div className={styles.error}>{error}</div>}\n      \n      <form onSubmit={handleSubmit}>\n        <div className={styles.formGroup}>\n          <label htmlFor="question">Question</label>\n          <input\n            id="question"\n            type="text"\n            value={question}\n            onChange={(e) => setQuestion(e.target.value)}\n            placeholder="Ask a question..."\n            maxLength={200}\n            required\n          />\n        </div>\n        \n        <div className={styles.formGroup}>\n          <label>Options</label>\n          {options.map((option, index) => (\n            <div key={index} className={styles.optionRow}>\n              <input\n                type="text"\n                value={option}\n                onChange={(e) => handleOptionChange(index, e.target.value)}\n                placeholder={`Option ${index + 1}`}\n                maxLength={100}\n              />\n              {options.length > 2 && (\n                <button\n                  type="button"\n                  className={styles.removeOption}\n                  onClick={() => handleRemoveOption(index)}\n                >\n                  \u2715\n                </button>\n              )}\n            </div>\n          ))}\n          \n          {options.length < 10 && (\n            <button\n              type="button"\n              className={styles.addOption}\n              onClick={handleAddOption}\n            >\n              + Add Option\n            </button>\n          )}\n        </div>\n        \n        <div className={styles.formGroup}>\n          <label htmlFor="expiration">Expires after</label>\n          <select\n            id="expiration"\n            value={expiration}\n            onChange={(e) => setExpiration(e.target.value)}\n          >\n            <option value="60">1 hour</option>\n            <option value="360">6 hours</option>\n            <option value="720">12 hours</option>\n            <option value="1440">24 hours</option>\n            <option value="4320">3 days</option>\n            <option value="10080">7 days</option>\n          </select>\n        </div>\n        \n        <div className={styles.actions}>\n          <button\n            type="button"\n            className={styles.cancelButton}\n            onClick={onClose}\n          >\n            Cancel\n          </button>\n          \n          <button\n            type="submit"\n            className={styles.createButton}\n            disabled={isSubmitting}\n          >\n            {isSubmitting ? \'Creating...\' : \'Create Poll\'}\n          </button>\n        </div>\n      </form>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"poll-display-component",children:"Poll Display Component"}),"\n",(0,o.jsx)(e.p,{children:"For displaying polls in the chat, I created a dedicated component:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:"// src/components/chat/PollMessage.jsx\nimport { useState } from 'react';\nimport { useAuth } from '../../contexts/AuthContext';\nimport { useChat } from '../../contexts/ChatContext';\nimport styles from './PollMessage.module.css';\n\nexport default function PollMessage({ message, chatId }) {\n  const { user } = useAuth();\n  const { votePoll, closePoll } = useChat();\n  \n  const [isVoting, setIsVoting] = useState(false);\n  \n  const {\n    question,\n    options = {},\n    voters = {},\n    isOpen,\n    expiresAt,\n    sender\n  } = message;\n  \n  // Check if poll has expired\n  const hasExpired = expiresAt && Date.now() > expiresAt;\n  \n  // Get the user's vote if they've already voted\n  const userVote = voters[user?.uid] || null;\n  \n  // Calculate total votes\n  const totalVotes = Object.values(voters).length;\n  \n  // Format options with vote counts and percentages\n  const formattedOptions = Object.entries(options).map(([key, option]) => {\n    const voteCount = Object.values(voters).filter(vote => vote === key).length;\n    const percentage = totalVotes > 0 ? Math.round((voteCount / totalVotes) * 100) : 0;\n    \n    return {\n      id: key,\n      text: option.text,\n      votes: voteCount,\n      percentage\n    };\n  });\n  \n  // Format time remaining\n  const formatTimeRemaining = () => {\n    if (!expiresAt || !isOpen) return '';\n    \n    const remaining = expiresAt - Date.now();\n    if (remaining <= 0) return 'Expired';\n    \n    const hours = Math.floor(remaining / (1000 * 60 * 60));\n    const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));\n    \n    if (hours > 24) {\n      const days = Math.floor(hours / 24);\n      return `${days} day${days !== 1 ? 's' : ''} left`;\n    }\n    \n    if (hours > 0) {\n      return `${hours} hr${hours !== 1 ? 's' : ''} ${minutes} min left`;\n    }\n    \n    return `${minutes} min left`;\n  };\n  \n  // Handle voting\n  const handleVote = async (optionId) => {\n    if (!isOpen || hasExpired) return;\n    \n    setIsVoting(true);\n    try {\n      await votePoll(chatId, message.id, optionId);\n    } catch (error) {\n      console.error('Error voting:', error);\n    } finally {\n      setIsVoting(false);\n    }\n  };\n  \n  // Handle closing the poll\n  const handleClose = async () => {\n    if (!isOpen) return;\n    \n    try {\n      await closePoll(chatId, message.id);\n    } catch (error) {\n      console.error('Error closing poll:', error);\n    }\n  };\n  \n  return (\n    <div className={styles.pollMessage}>\n      <div className={styles.pollHeader}>\n        <h4 className={styles.question}>{question}</h4>\n        \n        <div className={styles.pollStatus}>\n          {!isOpen ? (\n            <span className={styles.closed}>Closed</span>\n          ) : hasExpired ? (\n            <span className={styles.expired}>Expired</span>\n          ) : (\n            <span className={styles.timeRemaining}>{formatTimeRemaining()}</span>\n          )}\n        </div>\n      </div>\n      \n      <div className={styles.options}>\n        {formattedOptions.map(option => {\n          const isSelected = userVote === option.id;\n          \n          return (\n            <button\n              key={option.id}\n              className={`${styles.option} ${isSelected ? styles.selected : ''}`}\n              onClick={() => handleVote(option.id)}\n              disabled={!isOpen || hasExpired || isVoting || !!userVote}\n            >\n              <div className={styles.optionText}>\n                {option.text}\n                {isSelected && <span className={styles.checkmark}>\u2713</span>}\n              </div>\n              \n              <div className={styles.voteBar}>\n                <div \n                  className={styles.voteBarFill}\n                  style={{ width: `${option.percentage}%` }}\n                />\n              </div>\n              \n              <div className={styles.voteInfo}>\n                <span className={styles.votePercentage}>{option.percentage}%</span>\n                <span className={styles.voteCount}>\n                  {option.votes} vote{option.votes !== 1 ? 's' : ''}\n                </span>\n              </div>\n            </button>\n          );\n        })}\n      </div>\n      \n      <div className={styles.pollFooter}>\n        <span className={styles.totalVotes}>\n          {totalVotes} vote{totalVotes !== 1 ? 's' : ''}\n        </span>\n        \n        {isOpen && !hasExpired && sender === user?.uid && (\n          <button \n            onClick={handleClose}\n            className={styles.closeButton}\n          >\n            Close Poll\n          </button>\n        )}\n      </div>\n    </div>\n  );\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"voting-and-closing-polls",children:"Voting and Closing Polls"}),"\n",(0,o.jsx)(e.p,{children:"I added these crucial functions to the ChatContext:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:"// In ChatContext.jsx\n// Vote on a poll\nconst votePoll = async (chatId, pollId, optionId) => {\n  if (!chatId || !pollId || !optionId || !user?.uid) return;\n  \n  try {\n    // Get the current poll data\n    const pollRef = ref(db, `messages/${chatId}/${pollId}`);\n    const snapshot = await get(pollRef);\n    \n    if (!snapshot.exists()) {\n      throw new Error('Poll not found');\n    }\n    \n    const pollData = snapshot.val();\n    \n    // Check if the poll is still open\n    if (!pollData.isOpen) {\n      throw new Error('This poll is closed');\n    }\n    \n    // Check if the poll has expired\n    if (pollData.expiresAt && pollData.expiresAt < Date.now()) {\n      // Auto-close the poll\n      await update(pollRef, { isOpen: false });\n      throw new Error('This poll has expired');\n    }\n    \n    // Record the user's vote\n    await update(pollRef, {\n      [`voters/${user.uid}`]: optionId\n    });\n    \n    return true;\n  } catch (error) {\n    console.error('Error voting on poll:', error);\n    return false;\n  }\n};\n\n// Close a poll\nconst closePoll = async (chatId, pollId) => {\n  if (!chatId || !pollId || !user?.uid) return;\n  \n  try {\n    // Get the poll data\n    const pollRef = ref(db, `messages/${chatId}/${pollId}`);\n    const snapshot = await get(pollRef);\n    \n    if (!snapshot.exists()) {\n      throw new Error('Poll not found');\n    }\n    \n    const pollData = snapshot.val();\n    \n    // Check if the user is authorized to close the poll\n    if (pollData.sender !== user.uid && !isCurrentUserAdmin()) {\n      throw new Error('You cannot close this poll');\n    }\n    \n    // Close the poll\n    await update(pollRef, { isOpen: false });\n    \n    return true;\n  } catch (error) {\n    console.error('Error closing poll:', error);\n    return false;\n  }\n};\n"})}),"\n",(0,o.jsx)(e.h2,{id:"integration-with-messageinput",children:"Integration with MessageInput"}),"\n",(0,o.jsx)(e.p,{children:"I added a poll button to the message input component:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'// In MessageInput.jsx\nconst [showPollCreator, setShowPollCreator] = useState(false);\n\n// In the JSX part\n<div className={styles.messageInputContainer}>\n  {/* Other input elements */}\n  \n  <button\n    type="button"\n    className={styles.pollButton}\n    onClick={() => setShowPollCreator(true)}\n    aria-label="Create poll"\n  >\n    \ud83d\udcca\n  </button>\n  \n  {showPollCreator && (\n    <div className={styles.modalOverlay}>\n      <div className={styles.modalContent}>\n        <PollCreator onClose={() => setShowPollCreator(false)} />\n      </div>\n    </div>\n  )}\n</div>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"auto-expiring-polls",children:"Auto-expiring Polls"}),"\n",(0,o.jsx)(e.p,{children:"To handle expired polls, I set up a background process:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:"// In ChatArea.jsx\n// Check for expired polls periodically\nuseEffect(() => {\n  const checkExpiredPolls = async () => {\n    if (!messages.length || !currentChat?.id) return;\n    \n    const now = Date.now();\n    const updates = {};\n    \n    const expiredPolls = messages.filter(msg => \n      msg.type === 'poll' && \n      msg.isOpen && \n      msg.expiresAt && \n      msg.expiresAt < now\n    );\n    \n    for (const poll of expiredPolls) {\n      updates[`messages/${currentChat.id}/${poll.id}/isOpen`] = false;\n    }\n    \n    if (Object.keys(updates).length > 0) {\n      try {\n        await update(ref(db), updates);\n      } catch (error) {\n        console.error('Error updating expired polls:', error);\n      }\n    }\n  };\n  \n  // Check when component mounts\n  checkExpiredPolls();\n  \n  // Set up interval to check every minute\n  const interval = setInterval(checkExpiredPolls, 60000);\n  \n  return () => clearInterval(interval);\n}, [messages, currentChat?.id]);\n"})}),"\n",(0,o.jsx)(e.h2,{id:"technical-challenges",children:"Technical Challenges"}),"\n",(0,o.jsx)(e.h3,{id:"real-time-updates",children:"Real-time Updates"}),"\n",(0,o.jsx)(e.p,{children:"Getting real-time updates for polls was crucial for a good user experience:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:"// In ChatContext.jsx - Handling poll updates in the message listener\nuseEffect(() => {\n  if (!currentChat?.id) return;\n  \n  const messagesRef = ref(db, `messages/${currentChat.id}`);\n  \n  // Listen for all message changes\n  const unsubscribe = onChildChanged(messagesRef, (snapshot) => {\n    const updatedMessage = {\n      id: snapshot.key,\n      ...snapshot.val()\n    };\n    \n    // Update the message in our local state\n    setMessages(prev => \n      prev.map(msg => \n        msg.id === updatedMessage.id ? updatedMessage : msg\n      )\n    );\n  });\n  \n  return () => unsubscribe();\n}, [currentChat?.id]);\n"})}),"\n",(0,o.jsx)(e.h3,{id:"race-conditions",children:"Race Conditions"}),"\n",(0,o.jsx)(e.p,{children:"I had to be careful with race conditions when multiple users vote at the same time:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:"// In ChatContext.jsx - Using transactions to prevent race conditions\nconst votePoll = async (chatId, pollId, optionId) => {\n  // ... other code\n  \n  try {\n    const pollRef = ref(db, `messages/${chatId}/${pollId}`);\n    \n    // Use a transaction to handle concurrent votes\n    await runTransaction(pollRef, (currentPoll) => {\n      if (!currentPoll) return null; // Abort if poll doesn't exist\n      \n      // Check if poll is still open\n      if (!currentPoll.isOpen || \n          (currentPoll.expiresAt && currentPoll.expiresAt < Date.now())) {\n        return currentPoll; // Don't modify, just return current value\n      }\n      \n      // Initialize voters object if it doesn't exist\n      if (!currentPoll.voters) {\n        currentPoll.voters = {};\n      }\n      \n      // Record the user's vote\n      currentPoll.voters[user.uid] = optionId;\n      \n      return currentPoll;\n    });\n    \n    return true;\n  } catch (error) {\n    console.error('Error voting on poll:', error);\n    return false;\n  }\n};\n"})}),"\n",(0,o.jsx)(e.h3,{id:"ui-design-challenges",children:"UI Design Challenges"}),"\n",(0,o.jsx)(e.p,{children:"Creating a mobile-friendly poll UI was tricky:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-css",children:"/* PollMessage.module.css */\n.pollMessage {\n  width: 100%;\n  max-width: 500px;\n  background-color: #f5f8ff;\n  border-radius: 8px;\n  padding: 12px;\n  margin-bottom: 8px;\n}\n\n/* Make sure the poll is usable on mobile */\n@media (max-width: 576px) {\n  .pollMessage {\n    width: 100%;\n    max-width: none;\n  }\n  \n  .option {\n    padding: 8px;\n  }\n  \n  .voteInfo {\n    font-size: 12px;\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,o.jsx)(e.p,{children:"If I had more time to work on the polling feature, I'd add:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Multiple Choice"})," - Allow users to vote for multiple options"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Poll Templates"})," - Quick templates for common poll types"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Image Options"})," - Add images to poll options"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Vote Tracking"})," - Show who voted for what (for admins only)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Poll Analytics"})," - More detailed statistics about voting patterns"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Poll Sharing"})," - Ability to share polls in other chats"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Overall, the polls feature has been one of the most popular additions to the chat app. It makes group decision-making much easier and adds an interactive element to conversations."})]})}function d(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>r});var s=t(6540);const o={},l=s.createContext(o);function i(n){const e=s.useContext(l);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:i(n.components),s.createElement(l.Provider,{value:e},n.children)}}}]);