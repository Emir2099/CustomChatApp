"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[7982],{5962:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>g,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"Features/message-edit-delete","title":"Message Edit & Delete","description":"Adding edit and delete capabilities to messages was a must-have feature for me. We\'ve all sent messages with typos or regretted something we\'ve said, so implementing these features really improved the user experience.","source":"@site/docs-source/Features/message-edit-delete.md","sourceDirName":"Features","slug":"/Features/message-edit-delete","permalink":"/CustomChatApp/docs/Features/message-edit-delete","draft":false,"unlisted":false,"editUrl":"https://github.com/Emir2099/CustomChatApp/docs-source/Features/message-edit-delete.md","tags":[],"version":"current","lastUpdatedAt":1747596452000,"sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"User Profile Management","permalink":"/CustomChatApp/docs/Features/user-profile"},"next":{"title":"Load More Messages","permalink":"/CustomChatApp/docs/Features/load-more-messages"}}');var a=s(4848),i=s(8453);const r={sidebar_position:9},o="Message Edit & Delete",d={},l=[{value:"How Message Edit Works",id:"how-message-edit-works",level:2},{value:"How Message Delete Works",id:"how-message-delete-works",level:2},{value:"Message UI Components",id:"message-ui-components",level:2},{value:"Admin Capabilities",id:"admin-capabilities",level:2},{value:"Message History Tracking",id:"message-history-tracking",level:2},{value:"UI Considerations",id:"ui-considerations",level:2},{value:"Technical Challenges",id:"technical-challenges",level:2},{value:"Handling Edit UI",id:"handling-edit-ui",level:3},{value:"Soft Deletes vs. Hard Deletes",id:"soft-deletes-vs-hard-deletes",level:3},{value:"Race Conditions",id:"race-conditions",level:3},{value:"Future Improvements",id:"future-improvements",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"message-edit--delete",children:"Message Edit & Delete"})}),"\n",(0,a.jsx)(n.p,{children:"Adding edit and delete capabilities to messages was a must-have feature for me. We've all sent messages with typos or regretted something we've said, so implementing these features really improved the user experience."}),"\n",(0,a.jsx)(n.h2,{id:"how-message-edit-works",children:"How Message Edit Works"}),"\n",(0,a.jsx)(n.p,{children:"The edit feature allows users to modify their own messages after sending them. Here's how I implemented it:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In ChatContext.jsx\nconst editMessage = async (chatId, messageId, newContent) => {\n  if (!chatId || !messageId || !newContent.trim()) return;\n  \n  try {\n    const messageRef = ref(db, `messages/${chatId}/${messageId}`);\n    const snapshot = await get(messageRef);\n    \n    if (!snapshot.exists()) {\n      throw new Error('Message does not exist');\n    }\n    \n    const messageData = snapshot.val();\n    \n    // Check if the user can edit this message\n    if (messageData.sender !== user.uid && !isCurrentUserAdmin()) {\n      throw new Error('You cannot edit this message');\n    }\n    \n    // Log the edit\n    await logMessageEdit(chatId, messageId, messageData.content, newContent);\n    \n    // Update the message\n    await update(messageRef, {\n      content: newContent,\n      edited: true,\n      editedAt: serverTimestamp()\n    });\n    \n    // If this is the last message, update the chat's last message\n    if (currentChat?.lastMessage?.timestamp === messageData.timestamp) {\n      await update(ref(db, `chats/${chatId}`), {\n        lastMessage: {\n          ...currentChat.lastMessage,\n          content: newContent\n        }\n      });\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error editing message:', error);\n    return false;\n  }\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"how-message-delete-works",children:"How Message Delete Works"}),"\n",(0,a.jsx)(n.p,{children:'For deletion, I implemented a "soft delete" approach - messages aren\'t actually removed from the database, but marked as deleted:'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In ChatContext.jsx\nconst deleteMessage = async (chatId, messageId) => {\n  if (!chatId || !messageId) return;\n  \n  try {\n    const messageRef = ref(db, `messages/${chatId}/${messageId}`);\n    const snapshot = await get(messageRef);\n    \n    if (!snapshot.exists()) {\n      throw new Error('Message does not exist');\n    }\n    \n    const messageData = snapshot.val();\n    \n    // Check if the user can delete this message\n    if (messageData.sender !== user.uid && !isCurrentUserAdmin()) {\n      throw new Error('You cannot delete this message');\n    }\n    \n    // Log the deletion\n    await logMessageDelete(chatId, messageId, messageData.content);\n    \n    // Mark as deleted (soft delete)\n    await update(messageRef, {\n      deleted: true,\n      content: 'This message has been deleted',\n      deletedAt: serverTimestamp()\n    });\n    \n    return true;\n  } catch (error) {\n    console.error('Error deleting message:', error);\n    return false;\n  }\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"message-ui-components",children:"Message UI Components"}),"\n",(0,a.jsx)(n.p,{children:"Users can access edit and delete options through a context menu on their own messages:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In MessageItem.jsx\nfunction MessageItem({ message, isOwnMessage }) {\n  const [showOptions, setShowOptions] = useState(false);\n  const { editMessage, deleteMessage } = useChat();\n  const [isEditing, setIsEditing] = useState(false);\n  const [editContent, setEditContent] = useState('');\n  \n  const handleEdit = () => {\n    setEditContent(message.content);\n    setIsEditing(true);\n    setShowOptions(false);\n  };\n  \n  const handleDelete = async () => {\n    if (window.confirm('Are you sure you want to delete this message?')) {\n      await deleteMessage(currentChat.id, message.id);\n    }\n    setShowOptions(false);\n  };\n  \n  const handleSaveEdit = async () => {\n    if (editContent.trim() && editContent !== message.content) {\n      await editMessage(currentChat.id, message.id, editContent);\n    }\n    setIsEditing(false);\n  };\n  \n  return (\n    <div \n      className={`${styles.messageItem} ${isOwnMessage ? styles.ownMessage : ''}`}\n      onMouseEnter={() => setShowOptions(true)}\n      onMouseLeave={() => setShowOptions(false)}\n    >\n      {isEditing ? (\n        <div className={styles.editContainer}>\n          <textarea\n            value={editContent}\n            onChange={(e) => setEditContent(e.target.value)}\n            autoFocus\n          />\n          <div className={styles.editActions}>\n            <button onClick={() => setIsEditing(false)}>Cancel</button>\n            <button onClick={handleSaveEdit}>Save</button>\n          </div>\n        </div>\n      ) : (\n        <>\n          <div className={styles.content}>\n            {message.deleted ? (\n              <span className={styles.deletedMessage}>\n                This message has been deleted\n              </span>\n            ) : (\n              message.content\n            )}\n          </div>\n          \n          {message.edited && !message.deleted && (\n            <span className={styles.editedTag}>\n              (edited)\n            </span>\n          )}\n          \n          {showOptions && isOwnMessage && !message.deleted && (\n            <div className={styles.messageOptions}>\n              <button onClick={handleEdit}>\n                <EditIcon /> Edit\n              </button>\n              <button onClick={handleDelete}>\n                <DeleteIcon /> Delete\n              </button>\n            </div>\n          )}\n        </>\n      )}\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"admin-capabilities",children:"Admin Capabilities"}),"\n",(0,a.jsx)(n.p,{children:"I also gave admins the ability to edit and delete any message:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In MessageItem.jsx - Modified version with admin capabilities\nfunction MessageItem({ message }) {\n  // ... other code\n  \n  const { user, isCurrentUserAdmin } = useAuth();\n  const isOwnMessage = message.sender === user.uid;\n  const canModify = isOwnMessage || isCurrentUserAdmin();\n  \n  // ... other code\n  \n  return (\n    <div className={styles.messageItem}>\n      {/* ... other elements */}\n      \n      {showOptions && canModify && !message.deleted && (\n        <div className={styles.messageOptions}>\n          <button onClick={handleEdit}>\n            <EditIcon /> {isOwnMessage ? 'Edit' : 'Admin Edit'}\n          </button>\n          <button onClick={handleDelete}>\n            <DeleteIcon /> {isOwnMessage ? 'Delete' : 'Admin Delete'} \n          </button>\n        </div>\n      )}\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"message-history-tracking",children:"Message History Tracking"}),"\n",(0,a.jsx)(n.p,{children:"For accountability, I set up a logging system that tracks all edits and deletions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In ChatContext.jsx\nconst logMessageEdit = async (chatId, messageId, originalContent, newContent) => {\n  try {\n    const logRef = push(ref(db, `logs/${chatId}`));\n    \n    await set(logRef, {\n      messageId,\n      type: 'EDIT',\n      performedBy: user.uid,\n      performedByName: user.displayName,\n      timestamp: serverTimestamp(),\n      originalContent,\n      newContent\n    });\n  } catch (error) {\n    console.error('Error creating edit log:', error);\n  }\n};\n\nconst logMessageDelete = async (chatId, messageId, originalContent) => {\n  try {\n    const logRef = push(ref(db, `logs/${chatId}`));\n    \n    await set(logRef, {\n      messageId,\n      type: 'DELETE',\n      performedBy: user.uid,\n      performedByName: user.displayName,\n      timestamp: serverTimestamp(),\n      originalContent\n    });\n  } catch (error) {\n    console.error('Error creating delete log:', error);\n  }\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"ui-considerations",children:"UI Considerations"}),"\n",(0,a.jsx)(n.p,{children:"I wanted to make it clear when messages have been edited or deleted:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-css",children:"/* MessageItem.module.css */\n.deletedMessage {\n  font-style: italic;\n  color: #999;\n}\n\n.editedTag {\n  font-size: 11px;\n  color: #999;\n  margin-left: 5px;\n}\n\n.messageOptions {\n  position: absolute;\n  right: 10px;\n  top: 5px;\n  background-color: white;\n  border-radius: 4px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\n  overflow: hidden;\n  z-index: 5;\n}\n\n.messageOptions button {\n  display: flex;\n  align-items: center;\n  padding: 8px 12px;\n  background: none;\n  border: none;\n  width: 100%;\n  text-align: left;\n  cursor: pointer;\n}\n\n.messageOptions button:hover {\n  background-color: #f5f5f5;\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"technical-challenges",children:"Technical Challenges"}),"\n",(0,a.jsx)(n.h3,{id:"handling-edit-ui",children:"Handling Edit UI"}),"\n",(0,a.jsx)(n.p,{children:"Getting the edit UI right was a bit tricky - I wanted a smooth transition between viewing and editing:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In MessageItem.jsx - Edit mode transition\nuseEffect(() => {\n  if (isEditing) {\n    // Auto-resize textarea to match content\n    const textarea = textareaRef.current;\n    if (textarea) {\n      textarea.style.height = 'auto';\n      textarea.style.height = `${textarea.scrollHeight}px`;\n    }\n    \n    // Focus and place cursor at the end\n    if (textarea) {\n      textarea.focus();\n      textarea.selectionStart = textarea.selectionEnd = textarea.value.length;\n    }\n  }\n}, [isEditing]);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"soft-deletes-vs-hard-deletes",children:"Soft Deletes vs. Hard Deletes"}),"\n",(0,a.jsx)(n.p,{children:"I debated whether to fully remove messages or just mark them as deleted. I went with soft deletes for a few reasons:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"It preserves conversation flow - gaps in the chat can be confusing"}),"\n",(0,a.jsx)(n.li,{children:"It provides accountability - we know who deleted what and when"}),"\n",(0,a.jsx)(n.li,{children:"It allows for potential message recovery in the future"}),"\n",(0,a.jsx)(n.li,{children:"It's consistent with other chat platforms users are familiar with"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"race-conditions",children:"Race Conditions"}),"\n",(0,a.jsx)(n.p,{children:"When multiple users are editing or deleting messages simultaneously, race conditions can occur. I added some safeguards:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In editMessage - Add transaction to prevent race conditions\nconst editMessage = async (chatId, messageId, newContent) => {\n  // ... existing code\n  \n  try {\n    const messageRef = ref(db, `messages/${chatId}/${messageId}`);\n    \n    // Use transaction to handle concurrent edits\n    const success = await runTransaction(messageRef, (currentData) => {\n      if (!currentData) return null; // Abort if message doesn't exist\n      \n      // Check permissions again inside transaction\n      if (currentData.sender !== user.uid && !isCurrentUserAdmin()) {\n        return null; // Abort transaction\n      }\n      \n      // Only proceed if message hasn't been deleted since we started\n      if (currentData.deleted) return null;\n      \n      // Update the message\n      currentData.content = newContent;\n      currentData.edited = true;\n      currentData.editedAt = serverTimestamp();\n      \n      return currentData;\n    });\n    \n    // Log the edit only if transaction succeeded\n    if (success) {\n      await logMessageEdit(chatId, messageId, messageData.content, newContent);\n    }\n    \n    return success;\n  } catch (error) {\n    console.error('Error editing message:', error);\n    return false;\n  }\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,a.jsx)(n.p,{children:"If I had more time to work on these features, I'd add:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Edit History"})," - Allow users (or at least admins) to view the full edit history of a message"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Time Limits"})," - Add configurable time limits for editing/deleting (e.g., can only edit within 5 minutes)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Edit Indicators"})," - Show when someone is currently editing a message, similar to typing indicators"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Restore Option"})," - Give admins the ability to restore deleted messages"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Bulk Delete"})," - Allow admins to delete multiple messages at once"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Forward Message"})," - Add ability to forward messages to other chats"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Overall, I'm pretty happy with how the edit and delete features turned out. They provide the essential functionality that users expect while maintaining the integrity of conversations."})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>o});var t=s(6540);const a={},i=t.createContext(a);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);