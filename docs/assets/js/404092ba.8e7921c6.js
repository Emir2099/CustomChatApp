"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2953],{3761:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"Features/user-presence-system","title":"User Presence System","description":"Building a reliable user presence system was essential to create a responsive and engaging chat experience. I wanted users to know who\'s currently online, who\'s typing, and when someone has read their messages.","source":"@site/docs-source/Features/user-presence-system.md","sourceDirName":"Features","slug":"/Features/user-presence-system","permalink":"/CustomChatApp/docs/Features/user-presence-system","draft":false,"unlisted":false,"editUrl":"https://github.com/Emir2099/CustomChatApp/docs-source/Features/user-presence-system.md","tags":[],"version":"current","lastUpdatedAt":1747596452000,"sidebarPosition":16,"frontMatter":{"sidebar_position":16},"sidebar":"tutorialSidebar","previous":{"title":"Message Search","permalink":"/CustomChatApp/docs/Features/message-search"},"next":{"title":"Chat Groups Management","permalink":"/CustomChatApp/docs/Features/chat-groups-management"}}');var a=s(4848),r=s(8453);const i={sidebar_position:16},c="User Presence System",o={},l=[{value:"Core Presence Architecture",id:"core-presence-architecture",level:2},{value:"Online Indicators",id:"online-indicators",level:2},{value:"Typing Indicators",id:"typing-indicators",level:2},{value:"Read Receipts",id:"read-receipts",level:2},{value:"User Activity Tracking",id:"user-activity-tracking",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Technical Challenges",id:"technical-challenges",level:2},{value:"Connection Reliability",id:"connection-reliability",level:3},{value:"Data Consistency",id:"data-consistency",level:3},{value:"Future Improvements",id:"future-improvements",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"user-presence-system",children:"User Presence System"})}),"\n",(0,a.jsx)(n.p,{children:"Building a reliable user presence system was essential to create a responsive and engaging chat experience. I wanted users to know who's currently online, who's typing, and when someone has read their messages."}),"\n",(0,a.jsx)(n.h2,{id:"core-presence-architecture",children:"Core Presence Architecture"}),"\n",(0,a.jsx)(n.p,{children:"I designed the presence system around Firebase's Realtime Database because it's perfect for this use case - it handles real-time updates and automatically cleans up when connections drop:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// src/contexts/PresenceContext.jsx\nconst PresenceContext = createContext();\n\nexport function PresenceProvider({ children }) {\n  const [onlineUsers, setOnlineUsers] = useState({});\n  const [typingUsers, setTypingUsers] = useState({});\n  const [lastSeen, setLastSeen] = useState({});\n  \n  const { currentUser } = useAuth();\n  \n  useEffect(() => {\n    if (!currentUser) return;\n    \n    // Setup user presence monitoring\n    const userStatusRef = ref(db, `status/${currentUser.uid}`);\n    const connectedRef = ref(db, '.info/connected');\n    \n    const handleConnectionChange = (snapshot) => {\n      if (snapshot.val() === true) {\n        // User is connected\n        \n        // When I disconnect, remove this device from online devices\n        // and store the last time I was seen\n        onDisconnect(userStatusRef).update({\n          state: 'offline',\n          lastSeen: serverTimestamp(),\n          online: false\n        });\n        \n        // Register my current online state\n        update(userStatusRef, {\n          state: 'online',\n          lastSeen: serverTimestamp(),\n          online: true\n        });\n      }\n    };\n    \n    // Listen for connection state changes\n    onValue(connectedRef, handleConnectionChange);\n    \n    // Listen for online users\n    const allStatusRef = ref(db, 'status');\n    \n    const handleStatusChange = (snapshot) => {\n      if (snapshot.exists()) {\n        const statuses = snapshot.val();\n        const onlineUsersData = {};\n        const lastSeenData = {};\n        \n        Object.keys(statuses).forEach(userId => {\n          const userStatus = statuses[userId];\n          if (userStatus.online) {\n            onlineUsersData[userId] = true;\n          }\n          \n          if (userStatus.lastSeen) {\n            lastSeenData[userId] = userStatus.lastSeen;\n          }\n        });\n        \n        setOnlineUsers(onlineUsersData);\n        setLastSeen(lastSeenData);\n      }\n    };\n    \n    onValue(allStatusRef, handleStatusChange);\n    \n    return () => {\n      off(connectedRef);\n      off(allStatusRef);\n    };\n  }, [currentUser]);\n  \n  // Handle typing indicators\n  const setUserTyping = (chatId, isTyping) => {\n    if (!currentUser || !chatId) return;\n    \n    const typingRef = ref(db, `typing/${chatId}/${currentUser.uid}`);\n    \n    if (isTyping) {\n      set(typingRef, {\n        displayName: currentUser.displayName,\n        timestamp: serverTimestamp()\n      });\n      \n      // Auto-clear typing indicator after 10 seconds of inactivity\n      setTimeout(() => {\n        const lastTyped = Date.now();\n        if (lastTyped - Date.now() >= 10000) {\n          remove(typingRef);\n        }\n      }, 10000);\n    } else {\n      remove(typingRef);\n    }\n  };\n  \n  // Listen for typing indicators in a specific chat\n  const listenToTypingUsers = (chatId) => {\n    if (!chatId) return () => {};\n    \n    const typingRef = ref(db, `typing/${chatId}`);\n    \n    const handleTypingChange = (snapshot) => {\n      if (snapshot.exists()) {\n        const typingData = snapshot.val();\n        \n        // Filter out stale typing indicators (older than 10 seconds)\n        const now = Date.now();\n        const activeTyping = {};\n        Object.keys(typingData).forEach(userId => {\n          const userData = typingData[userId];\n          if (userId !== currentUser?.uid && userData.timestamp && \n              now - userData.timestamp < 10000) {\n            activeTyping[userId] = userData;\n          }\n        });\n        \n        setTypingUsers(prev => ({\n          ...prev,\n          [chatId]: activeTyping\n        }));\n      } else {\n        setTypingUsers(prev => ({\n          ...prev,\n          [chatId]: {}\n        }));\n      }\n    };\n    \n    onValue(typingRef, handleTypingChange);\n    \n    return () => off(typingRef);\n  };\n  \n  return (\n    <PresenceContext.Provider value={{\n      onlineUsers,\n      lastSeen,\n      typingUsers,\n      setUserTyping,\n      listenToTypingUsers,\n      isUserOnline: (userId) => !!onlineUsers[userId],\n      getUserLastSeen: (userId) => lastSeen[userId] || null,\n      getTypingUsers: (chatId) => typingUsers[chatId] || {}\n    }}>\n      {children}\n    </PresenceContext.Provider>\n  );\n}\n\nexport const usePresence = () => useContext(PresenceContext);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"online-indicators",children:"Online Indicators"}),"\n",(0,a.jsx)(n.p,{children:"I implemented visual indicators for online status within the user interface:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// src/components/common/UserAvatar.jsx\nfunction UserAvatar({ userId, size = \"medium\", showPresence = true }) {\n  const { getUserData } = useUsers();\n  const { isUserOnline } = usePresence();\n  \n  const user = getUserData(userId);\n  const isOnline = isUserOnline(userId);\n  \n  const sizeClassMap = {\n    small: styles.smallAvatar,\n    medium: styles.mediumAvatar,\n    large: styles.largeAvatar\n  };\n  \n  return (\n    <div className={styles.avatarContainer}>\n      <div className={`${styles.avatar} ${sizeClassMap[size] || sizeClassMap.medium}`}>\n        {user?.photoURL ? (\n          <img src={user.photoURL} alt={user.displayName || 'User'} />\n        ) : (\n          <div className={styles.defaultAvatar}>\n            {(user?.displayName?.charAt(0) || userId?.charAt(0) || '?').toUpperCase()}\n          </div>\n        )}\n      </div>\n      \n      {showPresence && (\n        <div className={`${styles.presenceIndicator} ${isOnline ? styles.online : styles.offline}`} />\n      )}\n    </div>\n  );\n}\n\n// src/components/chat/ContactsList.jsx\nfunction ContactsList() {\n  const { users, userChats, createOrOpenChat } = useUsers();\n  const { onlineUsers, getUserLastSeen } = usePresence();\n  const { formatDistanceToNow } = useDate();\n  \n  const sortedUsers = useMemo(() => {\n    return Object.values(users)\n      .sort((a, b) => {\n        // Online users first\n        if (onlineUsers[a.uid] && !onlineUsers[b.uid]) return -1;\n        if (!onlineUsers[a.uid] && onlineUsers[b.uid]) return 1;\n        \n        // Then by last seen (most recent first)\n        const aLastSeen = getUserLastSeen(a.uid) || 0;\n        const bLastSeen = getUserLastSeen(b.uid) || 0;\n        \n        return bLastSeen - aLastSeen;\n      });\n  }, [users, onlineUsers, getUserLastSeen]);\n\n  return (\n    <div className={styles.contactsList}>\n      <h3>Contacts</h3>\n      \n      {sortedUsers.length === 0 ? (\n        <div className={styles.emptyState}>No contacts found</div>\n      ) : (\n        <ul className={styles.contactItems}>\n          {sortedUsers.map(user => (\n            <li \n              key={user.uid}\n              className={styles.contactItem}\n              onClick={() => createOrOpenChat(user.uid)}\n            >\n              <UserAvatar userId={user.uid} size=\"small\" showPresence={true} />\n              \n              <div className={styles.contactInfo}>\n                <div className={styles.contactName}>\n                  {user.displayName}\n                </div>\n                \n                <div className={styles.contactStatus}>\n                  {onlineUsers[user.uid] ? (\n                    <span className={styles.onlineStatus}>Online</span>\n                  ) : getUserLastSeen(user.uid) ? (\n                    <span className={styles.lastSeenStatus}>\n                      Last seen {formatDistanceToNow(getUserLastSeen(user.uid))} ago\n                    </span>\n                  ) : (\n                    <span className={styles.unknownStatus}>Offline</span>\n                  )}\n                </div>\n              </div>\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"typing-indicators",children:"Typing Indicators"}),"\n",(0,a.jsx)(n.p,{children:"I implemented typing indicators to show when users are composing messages:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// src/components/chat/MessageInput.jsx\nfunction MessageInput() {\n  const [message, setMessage] = useState("");\n  const [isTyping, setIsTyping] = useState(false);\n  \n  const { currentChat, sendMessage } = useChat();\n  const { setUserTyping } = usePresence();\n  \n  // Track typing state and notify other users\n  useEffect(() => {\n    const typingTimeout = setTimeout(() => {\n      if (isTyping && message.length === 0) {\n        setIsTyping(false);\n        setUserTyping(currentChat?.id, false);\n      }\n    }, 2000);\n    \n    return () => clearTimeout(typingTimeout);\n  }, [message, isTyping, currentChat?.id, setUserTyping]);\n  \n  const handleInputChange = (e) => {\n    const newMessage = e.target.value;\n    setMessage(newMessage);\n    \n    // Update typing indicator state\n    if (newMessage.length > 0 && !isTyping) {\n      setIsTyping(true);\n      setUserTyping(currentChat?.id, true);\n    } else if (newMessage.length === 0 && isTyping) {\n      setIsTyping(false);\n      setUserTyping(currentChat?.id, false);\n    }\n  };\n  \n  const handleSendMessage = () => {\n    if (message.trim()) {\n      sendMessage({\n        content: message.trim(),\n        type: \'text\'\n      });\n      \n      setMessage("");\n      setIsTyping(false);\n      setUserTyping(currentChat?.id, false);\n    }\n  };\n  \n  // Rest of component...\n}\n\n// src/components/chat/TypingIndicator.jsx\nfunction TypingIndicator({ chatId }) {\n  const { getTypingUsers } = usePresence();\n  const typingUsers = getTypingUsers(chatId);\n  \n  if (Object.keys(typingUsers).length === 0) {\n    return null;\n  }\n  \n  return (\n    <div className={styles.typingIndicator}>\n      <div className={styles.dots}>\n        <div className={styles.dot}></div>\n        <div className={styles.dot}></div>\n        <div className={styles.dot}></div>\n      </div>\n      \n      <div className={styles.typingText}>\n        {Object.values(typingUsers).length === 1 ? (\n          <span>{Object.values(typingUsers)[0].displayName} is typing...</span>\n        ) : Object.values(typingUsers).length === 2 ? (\n          <span>{Object.values(typingUsers)[0].displayName} and {Object.values(typingUsers)[1].displayName} are typing...</span>\n        ) : (\n          <span>Several people are typing...</span>\n        )}\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"read-receipts",children:"Read Receipts"}),"\n",(0,a.jsx)(n.p,{children:"To let users know when their messages have been seen, I implemented read receipts:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// src/contexts/ChatContext.jsx\nexport function ChatProvider({ children }) {\n  // ... existing context code ...\n  \n  // Mark messages as read when viewed\n  const markMessagesAsRead = useCallback((chatId) => {\n    if (!currentUser || !chatId) return;\n    \n    const chatReadRef = ref(db, `chats/${chatId}/participants/${currentUser.uid}/lastRead`);\n    \n    set(chatReadRef, serverTimestamp())\n      .catch(error => {\n        console.error("Error marking messages as read:", error);\n      });\n  }, [currentUser]);\n  \n  // Exposing to consumers\n  const value = {\n    // ... other values\n    markMessagesAsRead\n  };\n  \n  return (\n    <ChatContext.Provider value={value}>\n      {children}\n    </ChatContext.Provider>\n  );\n}\n\n// src/components/chat/MessageList.jsx\nfunction MessageList() {\n  const { currentChat, messages, loadMessages, markMessagesAsRead } = useChat();\n  const listRef = useRef(null);\n  \n  useEffect(() => {\n    if (currentChat?.id) {\n      loadMessages(currentChat.id);\n      \n      // Mark messages as read when component mounts or chat changes\n      markMessagesAsRead(currentChat.id);\n    }\n  }, [currentChat?.id, loadMessages, markMessagesAsRead]);\n\n  // Also mark as read when scrolling through messages\n  useEffect(() => {\n    const handleScroll = debounce(() => {\n      if (currentChat?.id) {\n        markMessagesAsRead(currentChat.id);\n      }\n    }, 300);\n    \n    const listElement = listRef.current;\n    \n    if (listElement) {\n      listElement.addEventListener(\'scroll\', handleScroll);\n    }\n    \n    return () => {\n      if (listElement) {\n        listElement.removeEventListener(\'scroll\', handleScroll);\n      }\n    };\n  }, [currentChat?.id, markMessagesAsRead]);\n\n  // Rest of component...\n}\n\n// src/components/chat/MessageItem.jsx\nfunction MessageItem({ message }) {\n  const { currentUser } = useAuth();\n  const { currentChat } = useChat();\n  const fromMe = message.senderId === currentUser?.uid;\n  \n  // Determine if message has been read by other participants\n  const getReadStatus = () => {\n    if (!fromMe || !currentChat?.participants) return null;\n    \n    const otherParticipants = Object.entries(currentChat.participants)\n      .filter(([uid]) => uid !== currentUser.uid);\n    \n    if (otherParticipants.length === 0) return null;\n    \n    const readByCount = otherParticipants.filter(([, data]) => {\n      return data.lastRead && data.lastRead > message.timestamp;\n    }).length;\n    \n    if (readByCount === 0) {\n      return "Sent";\n    } else if (readByCount < otherParticipants.length) {\n      return "Read by some";\n    } else {\n      return "Read by all";\n    }\n  };\n  \n  const readStatus = getReadStatus();\n  \n  return (\n    <div className={`${styles.messageItem} ${fromMe ? styles.sentByMe : styles.receivedMessage}`}>\n      {/* Message content */}\n      <div className={styles.messageContent}>\n        {message.content}\n      </div>\n      \n      {/* Message metadata */}\n      <div className={styles.messageMetadata}>\n        <span className={styles.messageTime}>\n          {new Date(message.timestamp).toLocaleTimeString([], { hour: \'2-digit\', minute: \'2-digit\' })}\n        </span>\n        \n        {fromMe && readStatus && (\n          <span className={styles.readStatus}>\n            {readStatus === "Sent" && <SendIcon className={styles.sentIcon} />}\n            {readStatus === "Read by some" && <ReadIcon className={styles.partialReadIcon} />}\n            {readStatus === "Read by all" && <ReadIcon className={styles.readIcon} />}\n          </span>\n        )}\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"user-activity-tracking",children:"User Activity Tracking"}),"\n",(0,a.jsx)(n.p,{children:"To enhance the presence information, I added activity tracking functionality:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// src/utils/activityTracker.js\nexport const setupActivityTracking = (userId) => {\n  if (!userId) return () => {};\n  \n  const activityRef = ref(db, `activity/${userId}`);\n  let activityTimeout = null;\n  \n  const recordActivity = () => {\n    update(activityRef, {\n      lastActive: serverTimestamp(),\n      browser: getBrowserInfo(),\n      platform: getPlatformInfo(),\n      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone\n    });\n    \n    // Clear previous timeout and set a new one\n    if (activityTimeout) {\n      clearTimeout(activityTimeout);\n    }\n    \n    // Update activity every 5 minutes to avoid too many writes\n    activityTimeout = setTimeout(recordActivity, 5 * 60 * 1000);\n  };\n  \n  // Track common user interactions\n  const activityEvents = [\n    'mousedown', 'keydown', 'touchstart', 'scroll'\n  ];\n  \n  const handleUserActivity = debounce(recordActivity, 2000);\n  \n  activityEvents.forEach(event => {\n    window.addEventListener(event, handleUserActivity, { passive: true });\n  });\n  \n  // Initial activity record\n  recordActivity();\n  \n  // Clean up\n  return () => {\n    activityEvents.forEach(event => {\n      window.removeEventListener(event, handleUserActivity);\n    });\n    \n    if (activityTimeout) {\n      clearTimeout(activityTimeout);\n    }\n  };\n};\n\n// Integrated into the PresenceProvider\nuseEffect(() => {\n  if (!currentUser) return;\n  \n  const cleanupActivityTracking = setupActivityTracking(currentUser.uid);\n  \n  return () => {\n    cleanupActivityTracking();\n  };\n}, [currentUser]);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(n.p,{children:"The presence system can generate a lot of database operations, so I implemented several optimizations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// src/contexts/PresenceContext.jsx\n\n// Batching updates to minimize writes\nconst batchedSetUserTyping = (() => {\n  let pendingUpdates = {};\n  let timeout = null;\n  \n  return (chatId, isTyping) => {\n    if (!currentUser || !chatId) return;\n    \n    // Add to pending batch\n    pendingUpdates[chatId] = isTyping;\n    \n    if (!timeout) {\n      timeout = setTimeout(() => {\n        // Apply all pending updates at once\n        const updates = {};\n        Object.entries(pendingUpdates).forEach(([chatId, isTyping]) => {\n          if (isTyping) {\n            updates[`typing/${chatId}/${currentUser.uid}`] = {\n              displayName: currentUser.displayName,\n              timestamp: serverTimestamp()\n            };\n          } else {\n            updates[`typing/${chatId}/${currentUser.uid}`] = null;\n          }\n        });\n        \n        update(ref(db), updates);\n        \n        pendingUpdates = {};\n        timeout = null;\n      }, 300);\n    }\n  };\n})();\n\n// Limit presence subscription to active chats\nconst subscribeToPresence = (userIds) => {\n  if (!userIds || userIds.length === 0) return;\n  \n  const userStatusRefs = userIds.map(uid => ref(db, `status/${uid}`));\n  \n  userStatusRefs.forEach(statusRef => {\n    onValue(statusRef, (snapshot) => {\n      if (snapshot.exists()) {\n        const userId = statusRef.key;\n        const userData = snapshot.val();\n        \n        setOnlineUsers(prev => ({\n          ...prev,\n          [userId]: userData.online || false\n        }));\n        \n        if (userData.lastSeen) {\n          setLastSeen(prev => ({\n            ...prev,\n            [userId]: userData.lastSeen\n          }));\n        }\n      }\n    });\n  });\n  \n  return () => {\n    userStatusRefs.forEach(statusRef => {\n      off(statusRef);\n    });\n  };\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"technical-challenges",children:"Technical Challenges"}),"\n",(0,a.jsx)(n.h3,{id:"connection-reliability",children:"Connection Reliability"}),"\n",(0,a.jsx)(n.p,{children:"One of the biggest challenges was handling unreliable connections and ensuring presence data stayed accurate:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Connection Lost Detection"}),":"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// Integrated into PresenceProvider\nuseEffect(() => {\n  let connectionLostTime = null;\n  \n  const connectedRef = ref(db, '.info/connected');\n  const handleConnectionChange = (snapshot) => {\n    if (snapshot.val() === false && !connectionLostTime) {\n      // Connection lost\n      connectionLostTime = Date.now();\n    } else if (snapshot.val() === true && connectionLostTime) {\n      // Reconnected\n      const offlineDuration = Date.now() - connectionLostTime;\n      \n      // If offline for more than 1 minute, consider it a significant disconnect\n      if (offlineDuration > 60000 && currentUser) {\n        // Re-establish presence\n        const userStatusRef = ref(db, `status/${currentUser.uid}`);\n        update(userStatusRef, {\n          state: 'online',\n          lastSeen: serverTimestamp(),\n          online: true,\n          reconnected: true,\n          offlineDuration\n        });\n      }\n      \n      connectionLostTime = null;\n    }\n  };\n  \n  onValue(connectedRef, handleConnectionChange);\n  \n  return () => off(connectedRef);\n}, [currentUser]);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"data-consistency",children:"Data Consistency"}),"\n",(0,a.jsx)(n.p,{children:"Ensuring consistent presence information across multiple devices was another challenge:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In user-presence.js utility\nexport const manageMultiDevicePresence = (userId) => {\n  if (!userId) return () => {};\n  \n  const deviceId = generateDeviceId(); // Unique ID for this device instance\n  const userStatusRef = ref(db, `status/${userId}`);\n  const deviceStatusRef = ref(db, `status/${userId}/devices/${deviceId}`);\n  \n  // Register this device\n  set(deviceStatusRef, {\n    online: true,\n    lastSeen: serverTimestamp(),\n    userAgent: navigator.userAgent\n  });\n  \n  // When this device disconnects\n  onDisconnect(deviceStatusRef).remove();\n  \n  // Listen to all devices for this user\n  const devicesRef = ref(db, `status/${userId}/devices`);\n  \n  onValue(devicesRef, (snapshot) => {\n    if (snapshot.exists()) {\n      // User is online if any device is online\n      const devices = snapshot.val();\n      const anyDeviceOnline = Object.values(devices).some(device => device.online);\n      \n      // Update the aggregate status\n      update(userStatusRef, {\n        online: anyDeviceOnline,\n        deviceCount: Object.keys(devices).length,\n        lastSeen: anyDeviceOnline ? null : serverTimestamp()\n      });\n    } else {\n      // No devices online\n      update(userStatusRef, {\n        online: false,\n        deviceCount: 0,\n        lastSeen: serverTimestamp()\n      });\n    }\n  });\n  \n  // Clean up\n  return () => {\n    off(devicesRef);\n    remove(deviceStatusRef);\n  };\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,a.jsx)(n.p,{children:"I have several ideas to enhance the presence system:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Invisible Mode"})," - Allow users to appear offline while still using the app."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Selective Presence"})," - Let users choose who can see their online status."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Activity Status"}),' - Show more granular status like "Away" or "Busy" based on activity patterns.']}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Cross-Platform Sync"})," - Better synchronization of presence information across web and mobile apps."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Presence Analytics"})," - Track user engagement patterns to improve the application."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The presence system has been one of the most appreciated features by users, as it brings the chat experience closer to real-life interactions. People especially love the typing indicators as they create anticipation and make conversations feel more dynamic."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>c});var t=s(6540);const a={},r=t.createContext(a);function i(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);