"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[4324],{967:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"Features/invite-links","title":"Invite Links","description":"One of the most crucial features I built for the chat app was the ability to generate invite links. This makes it super easy to bring new people into conversations without the hassle of manually adding each person.","source":"@site/docs-source/Features/invite-links.md","sourceDirName":"Features","slug":"/Features/invite-links","permalink":"/CustomChatApp/docs/Features/invite-links","draft":false,"unlisted":false,"editUrl":"https://github.com/Emir2099/CustomChatApp/docs-source/Features/invite-links.md","tags":[],"version":"current","lastUpdatedAt":1747596452000,"sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"Load More Messages","permalink":"/CustomChatApp/docs/Features/load-more-messages"},"next":{"title":"Polls Feature","permalink":"/CustomChatApp/docs/Features/polls"}}');var s=t(4848),a=t(8453);const r={sidebar_position:11},o="Invite Links",c={},l=[{value:"How Invite Links Work",id:"how-invite-links-work",level:2},{value:"Generating Invite Links",id:"generating-invite-links",level:2},{value:"Invite Link UI",id:"invite-link-ui",level:2},{value:"Accepting Invites",id:"accepting-invites",level:2},{value:"ChatContext Integration",id:"chatcontext-integration",level:2},{value:"Invite Link Routes",id:"invite-link-routes",level:2},{value:"Technical Challenges",id:"technical-challenges",level:2},{value:"Security Considerations",id:"security-considerations",level:3},{value:"Managing Expired Links",id:"managing-expired-links",level:3},{value:"User Experience",id:"user-experience",level:3},{value:"Admin Controls",id:"admin-controls",level:2},{value:"Future Improvements",id:"future-improvements",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"invite-links",children:"Invite Links"})}),"\n",(0,s.jsx)(e.p,{children:"One of the most crucial features I built for the chat app was the ability to generate invite links. This makes it super easy to bring new people into conversations without the hassle of manually adding each person."}),"\n",(0,s.jsx)(e.h2,{id:"how-invite-links-work",children:"How Invite Links Work"}),"\n",(0,s.jsx)(e.p,{children:"The invite link system follows this basic flow:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"A chat member generates a unique invite link"}),"\n",(0,s.jsx)(e.li,{children:"The link contains an encoded invite token"}),"\n",(0,s.jsx)(e.li,{children:"When someone opens the link, the app validates the token"}),"\n",(0,s.jsx)(e.li,{children:"If valid, the user is added to the chat"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"generating-invite-links",children:"Generating Invite Links"}),"\n",(0,s.jsx)(e.p,{children:"Here's how I implemented the invite link generation:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",children:"// In ChatContext.jsx\nconst generateInviteLink = async (chatId) => {\n  if (!chatId || !user?.uid) return null;\n  \n  try {\n    // Get the chat to verify permissions\n    const chatRef = ref(db, `chats/${chatId}`);\n    const chatSnapshot = await get(chatRef);\n    \n    if (!chatSnapshot.exists()) {\n      throw new Error('Chat not found');\n    }\n    \n    const chatData = chatSnapshot.val();\n    \n    // Check if user is a member\n    if (!chatData.members || !chatData.members[user.uid]) {\n      throw new Error('You are not a member of this chat');\n    }\n    \n    // Generate a unique token\n    const token = generateUniqueToken();\n    const expiresAt = Date.now() + (7 * 24 * 60 * 60 * 1000); // 7 days from now\n    \n    // Save the invite in Firebase\n    const inviteRef = ref(db, `invites/${token}`);\n    await set(inviteRef, {\n      chatId,\n      createdBy: user.uid,\n      createdAt: serverTimestamp(),\n      expiresAt,\n      isActive: true\n    });\n    \n    // Create the full invite URL\n    const inviteLink = `${window.location.origin}/invite/${token}`;\n    return inviteLink;\n  } catch (error) {\n    console.error('Error generating invite link:', error);\n    return null;\n  }\n};\n\n// Helper function to generate a unique token\nconst generateUniqueToken = () => {\n  // Create a random string of characters\n  const randomPart = Math.random().toString(36).substring(2, 10);\n  const timePart = Date.now().toString(36);\n  \n  return `${randomPart}-${timePart}`;\n};\n"})}),"\n",(0,s.jsx)(e.h2,{id:"invite-link-ui",children:"Invite Link UI"}),"\n",(0,s.jsx)(e.p,{children:"I created a simple but effective UI for generating and sharing invite links:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",children:"// src/components/chat/InviteLink.jsx\nimport { useState } from 'react';\nimport { useChat } from '../../contexts/ChatContext';\nimport styles from './InviteLink.module.css';\n\nexport default function InviteLink({ chatId, onClose }) {\n  const [inviteLink, setInviteLink] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState('');\n  const [copied, setCopied] = useState(false);\n  \n  const { generateInviteLink } = useChat();\n  \n  const handleGenerateLink = async () => {\n    setLoading(true);\n    setError('');\n    \n    try {\n      const link = await generateInviteLink(chatId);\n      \n      if (!link) {\n        throw new Error('Failed to generate invite link');\n      }\n      \n      setInviteLink(link);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  const handleCopyLink = () => {\n    if (!inviteLink) return;\n    \n    navigator.clipboard.writeText(inviteLink)\n      .then(() => {\n        setCopied(true);\n        setTimeout(() => setCopied(false), 3000);\n      })\n      .catch(() => {\n        setError('Failed to copy link');\n      });\n  };\n  \n  return (\n    <div className={styles.inviteLinkContainer}>\n      <h3>Invite People to Chat</h3>\n      \n      {error && <div className={styles.error}>{error}</div>}\n      \n      {inviteLink ? (\n        <div className={styles.linkContainer}>\n          <input\n            type=\"text\"\n            value={inviteLink}\n            readOnly\n            className={styles.linkInput}\n          />\n          \n          <button \n            onClick={handleCopyLink} \n            className={styles.copyButton}\n            disabled={copied}\n          >\n            {copied ? 'Copied!' : 'Copy'}\n          </button>\n          \n          <div className={styles.expireNote}>\n            This link expires in 7 days\n          </div>\n        </div>\n      ) : (\n        <button\n          onClick={handleGenerateLink}\n          className={styles.generateButton}\n          disabled={loading}\n        >\n          {loading ? 'Generating...' : 'Generate Invite Link'}\n        </button>\n      )}\n      \n      <button \n        onClick={onClose} \n        className={styles.closeButton}\n      >\n        Close\n      </button>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"accepting-invites",children:"Accepting Invites"}),"\n",(0,s.jsx)(e.p,{children:"On the receiving end, I created a component to handle incoming invites:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",children:"// src/components/chat/AcceptInvite.jsx\nimport { useState, useEffect } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { ref, get, update } from 'firebase/database';\nimport { db } from '../../config/firebase';\nimport { useAuth } from '../../contexts/AuthContext';\nimport { useChat } from '../../contexts/ChatContext';\nimport styles from './AcceptInvite.module.css';\n\nexport default function AcceptInvite() {\n  const { token } = useParams();\n  const navigate = useNavigate();\n  const { user } = useAuth();\n  const { joinChat } = useChat();\n  \n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState('');\n  const [chatDetails, setChatDetails] = useState(null);\n  \n  useEffect(() => {\n    // Redirect to login if not authenticated\n    if (!user) {\n      // Store the invite URL in session storage so we can redirect back after login\n      sessionStorage.setItem('inviteRedirect', window.location.pathname);\n      navigate('/login');\n      return;\n    }\n    \n    const validateInvite = async () => {\n      setLoading(true);\n      \n      try {\n        if (!token) {\n          throw new Error('Invalid invite link');\n        }\n        \n        // Get the invite data\n        const inviteRef = ref(db, `invites/${token}`);\n        const snapshot = await get(inviteRef);\n        \n        if (!snapshot.exists()) {\n          throw new Error('This invite link is invalid or has expired');\n        }\n        \n        const inviteData = snapshot.val();\n        \n        // Check if invite is active and not expired\n        if (!inviteData.isActive) {\n          throw new Error('This invite link has been deactivated');\n        }\n        \n        if (inviteData.expiresAt < Date.now()) {\n          throw new Error('This invite link has expired');\n        }\n        \n        // Get chat details\n        const chatRef = ref(db, `chats/${inviteData.chatId}`);\n        const chatSnapshot = await get(chatRef);\n        \n        if (!chatSnapshot.exists()) {\n          throw new Error('The chat no longer exists');\n        }\n        \n        const chatData = chatSnapshot.val();\n        \n        // Check if the user is already a member\n        if (chatData.members && chatData.members[user.uid]) {\n          navigate(`/chat/${inviteData.chatId}`);\n          return;\n        }\n        \n        setChatDetails({\n          id: inviteData.chatId,\n          name: chatData.name,\n          memberCount: chatData.members ? Object.keys(chatData.members).length : 0\n        });\n        \n      } catch (err) {\n        console.error('Error validating invite:', err);\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    validateInvite();\n  }, [token, user, navigate]);\n  \n  const handleAcceptInvite = async () => {\n    if (!chatDetails?.id) return;\n    \n    try {\n      // Join the chat\n      await joinChat(chatDetails.id);\n      \n      // Navigate to the chat\n      navigate(`/chat/${chatDetails.id}`);\n    } catch (err) {\n      setError(`Failed to join chat: ${err.message}`);\n    }\n  };\n  \n  const handleDecline = () => {\n    navigate('/');\n  };\n  \n  if (loading) {\n    return (\n      <div className={styles.loadingContainer}>\n        <div className={styles.spinner}></div>\n        <p>Validating invite...</p>\n      </div>\n    );\n  }\n  \n  if (error) {\n    return (\n      <div className={styles.errorContainer}>\n        <div className={styles.errorIcon}>\u274c</div>\n        <h2>Invite Error</h2>\n        <p>{error}</p>\n        <button onClick={() => navigate('/')} className={styles.homeButton}>\n          Go to Home\n        </button>\n      </div>\n    );\n  }\n  \n  return (\n    <div className={styles.inviteContainer}>\n      <div className={styles.inviteCard}>\n        <div className={styles.chatIcon}>\ud83d\udcac</div>\n        <h2>Join Chat</h2>\n        \n        <div className={styles.chatInfo}>\n          <p>\n            <strong>Chat Name:</strong> {chatDetails.name}\n          </p>\n          <p>\n            <strong>Members:</strong> {chatDetails.memberCount}\n          </p>\n        </div>\n        \n        <div className={styles.actions}>\n          <button \n            onClick={handleDecline} \n            className={styles.declineButton}\n          >\n            Decline\n          </button>\n          <button \n            onClick={handleAcceptInvite} \n            className={styles.acceptButton}\n          >\n            Join Chat\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"chatcontext-integration",children:"ChatContext Integration"}),"\n",(0,s.jsx)(e.p,{children:"To handle the invite process, I added a joinChat function to the ChatContext:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",children:"// In ChatContext.jsx\nconst joinChat = async (chatId) => {\n  if (!chatId || !user?.uid) return false;\n  \n  try {\n    const chatRef = ref(db, `chats/${chatId}`);\n    const snapshot = await get(chatRef);\n    \n    if (!snapshot.exists()) {\n      throw new Error('Chat not found');\n    }\n    \n    // Add user to members\n    const updates = {\n      [`members/${user.uid}`]: {\n        role: 'member',\n        joinedAt: serverTimestamp()\n      }\n    };\n    \n    await update(ref(db, `chats/${chatId}`), updates);\n    \n    // Add a system message about the new user\n    const messageRef = push(ref(db, `messages/${chatId}`));\n    await set(messageRef, {\n      type: 'system',\n      content: `${user.displayName} joined the chat`,\n      timestamp: serverTimestamp()\n    });\n    \n    return true;\n  } catch (error) {\n    console.error('Error joining chat:', error);\n    return false;\n  }\n};\n"})}),"\n",(0,s.jsx)(e.h2,{id:"invite-link-routes",children:"Invite Link Routes"}),"\n",(0,s.jsx)(e.p,{children:"I set up a dedicated route in the app to handle invite links:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",children:"// In App.jsx\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport AcceptInvite from './components/chat/AcceptInvite';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        {/* Other routes */}\n        <Route path=\"/invite/:token\" element={<AcceptInvite />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"technical-challenges",children:"Technical Challenges"}),"\n",(0,s.jsx)(e.h3,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,s.jsx)(e.p,{children:"Handling invite links securely was really important:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",children:"// Security checks I implemented:\n// 1. Expiration dates\nconst expiresAt = Date.now() + (7 * 24 * 60 * 60 * 1000); // 7 days\n\n// 2. Active flag that can be toggled\nconst inviteData = {\n  // ...other fields\n  isActive: true\n};\n\n// 3. Token uniqueness and complexity\nconst generateUniqueToken = () => {\n  const randomBytes = new Uint8Array(16);\n  window.crypto.getRandomValues(randomBytes);\n  return Array.from(randomBytes)\n    .map(b => b.toString(16).padStart(2, '0'))\n    .join('');\n};\n"})}),"\n",(0,s.jsx)(e.h3,{id:"managing-expired-links",children:"Managing Expired Links"}),"\n",(0,s.jsx)(e.p,{children:"I created a background process to clean up expired invites:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",children:"// In a server function or scheduled client-side task\nconst cleanupExpiredInvites = async () => {\n  try {\n    const now = Date.now();\n    const invitesRef = ref(db, 'invites');\n    const invitesSnapshot = await get(invitesRef);\n    \n    if (!invitesSnapshot.exists()) return;\n    \n    const updates = {};\n    \n    invitesSnapshot.forEach(childSnapshot => {\n      const invite = childSnapshot.val();\n      \n      if (invite.expiresAt < now) {\n        // Mark as inactive instead of deleting to preserve history\n        updates[`${childSnapshot.key}/isActive`] = false;\n      }\n    });\n    \n    if (Object.keys(updates).length > 0) {\n      await update(invitesRef, updates);\n    }\n  } catch (error) {\n    console.error('Error cleaning up expired invites:', error);\n  }\n};\n"})}),"\n",(0,s.jsx)(e.h3,{id:"user-experience",children:"User Experience"}),"\n",(0,s.jsx)(e.p,{children:"I wanted to make joining a chat through an invite as smooth as possible:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",children:"// Handle case where user isn't logged in yet\nuseEffect(() => {\n  // After login, check if we need to redirect to an invite\n  const inviteRedirect = sessionStorage.getItem('inviteRedirect');\n  \n  if (user && inviteRedirect) {\n    sessionStorage.removeItem('inviteRedirect');\n    navigate(inviteRedirect);\n  }\n}, [user, navigate]);\n"})}),"\n",(0,s.jsx)(e.h2,{id:"admin-controls",children:"Admin Controls"}),"\n",(0,s.jsx)(e.p,{children:"I added the ability for chat admins to manage invites:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",children:"// In ChatSettings.jsx\nconst [invites, setInvites] = useState([]);\n\n// Fetch all invites for this chat\nuseEffect(() => {\n  if (!chatId || !isAdmin) return;\n  \n  const fetchInvites = async () => {\n    try {\n      // Query invites by chatId\n      const invitesRef = ref(db, 'invites');\n      const invitesQuery = query(\n        invitesRef,\n        orderByChild('chatId'),\n        equalTo(chatId)\n      );\n      \n      const snapshot = await get(invitesQuery);\n      \n      if (snapshot.exists()) {\n        const invitesList = [];\n        \n        snapshot.forEach(childSnapshot => {\n          invitesList.push({\n            id: childSnapshot.key,\n            ...childSnapshot.val()\n          });\n        });\n        \n        setInvites(invitesList);\n      }\n    } catch (error) {\n      console.error('Error fetching invites:', error);\n    }\n  };\n  \n  fetchInvites();\n}, [chatId, isAdmin]);\n\n// Function to revoke an invite\nconst revokeInvite = async (inviteId) => {\n  try {\n    await update(ref(db, `invites/${inviteId}`), {\n      isActive: false\n    });\n    \n    // Update local state\n    setInvites(prev => \n      prev.map(invite => \n        invite.id === inviteId \n          ? { ...invite, isActive: false } \n          : invite\n      )\n    );\n  } catch (error) {\n    console.error('Error revoking invite:', error);\n  }\n};\n"})}),"\n",(0,s.jsx)(e.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,s.jsx)(e.p,{children:"If I had more time to work on the invite links feature, I'd add:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Role-Based Invites"})," - Generate links for specific roles (admin, member, read-only)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Usage Limits"})," - Limit how many people can join with a single link"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Private Invites"})," - Email-specific invites that only work for certain addresses"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Approval System"})," - Make some invites require approval from admins"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Analytics"})," - Track how many times an invite link is clicked vs. accepted"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Invite Management"})," - Better UI for admins to see all active invites"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"The invite links feature has been super helpful for growing chat conversations - people can easily share links on other platforms and bring in new members without admin intervention for each person."})]})}function h(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>o});var i=t(6540);const s={},a=i.createContext(s);function r(n){const e=i.useContext(a);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);