"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[7586],{8392:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>g,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Features/admin-logs","title":"Admin Features & Message Logs","description":"I wanted the app to have some administrative capabilities, especially for monitoring message edits and deletions. This helps maintain accountability and provides a way to recover information if needed.","source":"@site/docs-source/Features/admin-logs.md","sourceDirName":"Features","slug":"/Features/admin-logs","permalink":"/CustomChatApp/docs/Features/admin-logs","draft":false,"unlisted":false,"editUrl":"https://github.com/Emir2099/CustomChatApp/docs-source/Features/admin-logs.md","tags":[],"version":"current","lastUpdatedAt":1747596735000,"sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"User Blocking System","permalink":"/CustomChatApp/docs/Features/user-blocking"},"next":{"title":"File Sharing Feature","permalink":"/CustomChatApp/docs/Features/file-sharing"}}');var o=t(4848),a=t(8453);const i={sidebar_position:5},r="Admin Features & Message Logs",l={},d=[{value:"Admin Privileges System",id:"admin-privileges-system",level:2},{value:"Message Logs System",id:"message-logs-system",level:2},{value:"Implementing the Logs in ChatContext",id:"implementing-the-logs-in-chatcontext",level:3},{value:"LogViewer Component",id:"logviewer-component",level:2},{value:"Adding the &quot;View Logs&quot; Button",id:"adding-the-view-logs-button",level:2},{value:"Styling the Log Viewer",id:"styling-the-log-viewer",level:2},{value:"Technical Challenges",id:"technical-challenges",level:2},{value:"Deciding What to Log",id:"deciding-what-to-log",level:3},{value:"Soft Deletes vs. Hard Deletes",id:"soft-deletes-vs-hard-deletes",level:3},{value:"Security Considerations",id:"security-considerations",level:3},{value:"Future Improvements",id:"future-improvements",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"admin-features--message-logs",children:"Admin Features & Message Logs"})}),"\n",(0,o.jsx)(n.p,{children:"I wanted the app to have some administrative capabilities, especially for monitoring message edits and deletions. This helps maintain accountability and provides a way to recover information if needed."}),"\n",(0,o.jsx)(n.h2,{id:"admin-privileges-system",children:"Admin Privileges System"}),"\n",(0,o.jsxs)(n.p,{children:["The admin privileges system is pretty straightforward. I store an ",(0,o.jsx)(n.code,{children:"isAdmin"})," flag in the user object in Firebase:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'/users/{userId}: {\n  // ... other user data\n  "isAdmin": true\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Then I added a helper function in the ChatContext to check if the current user has admin privileges:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"// In ChatContext.jsx\nconst isCurrentUserAdmin = useCallback(() => {\n  return user && userData && userData.isAdmin === true;\n}, [user, userData]);\n"})}),"\n",(0,o.jsx)(n.p,{children:"This isn't exactly Fort Knox security-wise, but it's good enough for our purposes. In a production app, I'd use Firebase security rules to restrict certain operations based on admin status."}),"\n",(0,o.jsx)(n.h2,{id:"message-logs-system",children:"Message Logs System"}),"\n",(0,o.jsx)(n.p,{children:"The message logs system tracks all edits and deletions in a dedicated collection:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'/logs/{chatId}/{logId}: {\n  "messageId": "abc123",\n  "type": "EDIT",        // or "DELETE"\n  "performedBy": "userId",\n  "timestamp": 1650120050000,\n  "originalContent": "Hello there",\n  "newContent": "Hello everyone" // Only for EDIT logs\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"implementing-the-logs-in-chatcontext",children:"Implementing the Logs in ChatContext"}),"\n",(0,o.jsx)(n.p,{children:"I added several new functions to the ChatContext to handle logs:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"// src/contexts/ChatContext.jsx\nconst [logs, setLogs] = useState([]);\n\n// Function to record a log when a message is edited\nconst logMessageEdit = async (chatId, messageId, originalContent, newContent) => {\n  try {\n    const logRef = push(ref(db, `logs/${chatId}`));\n    \n    await set(logRef, {\n      messageId,\n      type: 'EDIT',\n      performedBy: user.uid,\n      performedByName: user.displayName,\n      timestamp: serverTimestamp(),\n      originalContent,\n      newContent\n    });\n    \n    console.log('Edit log created');\n  } catch (error) {\n    console.error('Error creating edit log:', error);\n  }\n};\n\n// Function to record a log when a message is deleted\nconst logMessageDelete = async (chatId, messageId, originalContent) => {\n  try {\n    const logRef = push(ref(db, `logs/${chatId}`));\n    \n    await set(logRef, {\n      messageId,\n      type: 'DELETE',\n      performedBy: user.uid,\n      performedByName: user.displayName,\n      timestamp: serverTimestamp(),\n      originalContent\n    });\n    \n    console.log('Delete log created');\n  } catch (error) {\n    console.error('Error creating delete log:', error);\n  }\n};\n\n// Function to fetch logs for a specific chat\nconst fetchChatLogs = useCallback(async (chatId) => {\n  if (!isCurrentUserAdmin() || !chatId) {\n    return [];\n  }\n  \n  try {\n    const logsRef = ref(db, `logs/${chatId}`);\n    const snapshot = await get(logsRef);\n    \n    if (!snapshot.exists()) {\n      return [];\n    }\n    \n    const logsData = snapshot.val();\n    const logsList = Object.keys(logsData).map(key => ({\n      id: key,\n      ...logsData[key]\n    }));\n    \n    // Sort logs by timestamp (newest first)\n    return logsList.sort((a, b) => b.timestamp - a.timestamp);\n  } catch (error) {\n    console.error('Error fetching logs:', error);\n    return [];\n  }\n}, [isCurrentUserAdmin]);\n\n// Updated edit message function to include logging\nconst editMessage = async (chatId, messageId, newContent) => {\n  if (!chatId || !messageId || !newContent.trim()) return;\n  \n  try {\n    const messageRef = ref(db, `messages/${chatId}/${messageId}`);\n    const snapshot = await get(messageRef);\n    \n    if (!snapshot.exists()) {\n      throw new Error('Message does not exist');\n    }\n    \n    const messageData = snapshot.val();\n    \n    // Check if the user can edit this message\n    if (messageData.sender !== user.uid && !isCurrentUserAdmin()) {\n      throw new Error('You cannot edit this message');\n    }\n    \n    // Log the edit\n    await logMessageEdit(chatId, messageId, messageData.content, newContent);\n    \n    // Update the message\n    await update(messageRef, {\n      content: newContent,\n      edited: true,\n      editedAt: serverTimestamp()\n    });\n    \n    return true;\n  } catch (error) {\n    console.error('Error editing message:', error);\n    return false;\n  }\n};\n\n// Updated delete message function to include logging\nconst deleteMessage = async (chatId, messageId) => {\n  if (!chatId || !messageId) return;\n  \n  try {\n    const messageRef = ref(db, `messages/${chatId}/${messageId}`);\n    const snapshot = await get(messageRef);\n    \n    if (!snapshot.exists()) {\n      throw new Error('Message does not exist');\n    }\n    \n    const messageData = snapshot.val();\n    \n    // Check if the user can delete this message\n    if (messageData.sender !== user.uid && !isCurrentUserAdmin()) {\n      throw new Error('You cannot delete this message');\n    }\n    \n    // Log the deletion\n    await logMessageDelete(chatId, messageId, messageData.content);\n    \n    // Mark as deleted rather than actually deleting\n    await update(messageRef, {\n      deleted: true,\n      content: 'This message has been deleted',\n      deletedAt: serverTimestamp()\n    });\n    \n    return true;\n  } catch (error) {\n    console.error('Error deleting message:', error);\n    return false;\n  }\n};\n"})}),"\n",(0,o.jsx)(n.h2,{id:"logviewer-component",children:"LogViewer Component"}),"\n",(0,o.jsx)(n.p,{children:"I created a simple UI component to view the logs:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"// src/components/chat/LogViewer.jsx\nimport { useState, useEffect } from 'react';\nimport { useChat } from '../../contexts/ChatContext';\nimport styles from './LogViewer.module.css';\n\nexport default function LogViewer({ chatId, onClose }) {\n  const [logs, setLogs] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const { fetchChatLogs } = useChat();\n  \n  useEffect(() => {\n    const loadLogs = async () => {\n      setLoading(true);\n      const chatLogs = await fetchChatLogs(chatId);\n      setLogs(chatLogs);\n      setLoading(false);\n    };\n    \n    loadLogs();\n  }, [chatId, fetchChatLogs]);\n  \n  // Format timestamp to readable date\n  const formatDate = (timestamp) => {\n    if (!timestamp) return 'Unknown';\n    \n    const date = new Date(timestamp);\n    return date.toLocaleString();\n  };\n  \n  return (\n    <div className={styles.logViewer}>\n      <div className={styles.header}>\n        <h2>Message Logs</h2>\n        <button \n          className={styles.closeButton} \n          onClick={onClose}\n          aria-label=\"Close log viewer\"\n        >\n          \xd7\n        </button>\n      </div>\n      \n      {loading ? (\n        <div className={styles.loading}>Loading logs...</div>\n      ) : logs.length === 0 ? (\n        <div className={styles.noLogs}>No logs found for this chat</div>\n      ) : (\n        <div className={styles.logList}>\n          {logs.map(log => (\n            <div key={log.id} className={styles.logItem}>\n              <div className={styles.logHeader}>\n                <span className={styles.logType}>\n                  {log.type === 'EDIT' ? '\u270f\ufe0f Edit' : '\ud83d\uddd1\ufe0f Delete'}\n                </span>\n                <span className={styles.logTime}>{formatDate(log.timestamp)}</span>\n              </div>\n              \n              <div className={styles.logUser}>\n                <strong>By:</strong> {log.performedByName || 'Unknown user'}\n              </div>\n              \n              <div className={styles.logContent}>\n                <div className={styles.originalContent}>\n                  <strong>Original:</strong> {log.originalContent}\n                </div>\n                \n                {log.type === 'EDIT' && (\n                  <div className={styles.newContent}>\n                    <strong>Changed to:</strong> {log.newContent}\n                  </div>\n                )}\n              </div>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"adding-the-view-logs-button",children:'Adding the "View Logs" Button'}),"\n",(0,o.jsx)(n.p,{children:"I added a button to the chat header that's only visible to admins:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'// In ChatArea.jsx\nconst renderChatHeader = () => {\n  return (\n    <div className={styles.header}>\n      {/* Other header elements */}\n      \n      {isCurrentUserAdmin() && (\n        <button \n          className={styles.viewLogsButton}\n          onClick={() => setShowLogViewer(true)}\n          title="View message logs"\n        >\n          \ud83d\udccb Logs\n        </button>\n      )}\n    </div>\n  );\n};\n\n// Later in the component\nreturn (\n  <div className={styles.chatArea}>\n    {renderChatHeader()}\n    \n    {/* Rest of the component */}\n    \n    {showLogViewer && (\n      <LogViewer \n        chatId={currentChat.id} \n        onClose={() => setShowLogViewer(false)} \n      />\n    )}\n  </div>\n);\n'})}),"\n",(0,o.jsx)(n.h2,{id:"styling-the-log-viewer",children:"Styling the Log Viewer"}),"\n",(0,o.jsx)(n.p,{children:'I wanted the LogViewer to have a distinct "admin" feel:'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-css",children:"/* LogViewer.module.css */\n.logViewer {\n  position: absolute;\n  top: 0;\n  right: 0;\n  width: 350px;\n  height: 100%;\n  background-color: #f8f9fa;\n  border-left: 1px solid #dee2e6;\n  box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);\n  z-index: 10;\n  overflow-y: auto;\n  padding: 1rem;\n}\n\n.header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 1rem;\n  padding-bottom: 0.5rem;\n  border-bottom: 1px solid #dee2e6;\n}\n\n.header h2 {\n  margin: 0;\n  color: #343a40;\n}\n\n.closeButton {\n  background: none;\n  border: none;\n  font-size: 1.5rem;\n  cursor: pointer;\n  color: #6c757d;\n}\n\n.logList {\n  display: flex;\n  flex-direction: column;\n  gap: 1rem;\n}\n\n.logItem {\n  background-color: white;\n  border-radius: 8px;\n  padding: 0.75rem;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n}\n\n.logHeader {\n  display: flex;\n  justify-content: space-between;\n  margin-bottom: 0.5rem;\n}\n\n.logType {\n  font-weight: 500;\n}\n\n.logTime {\n  font-size: 0.8rem;\n  color: #6c757d;\n}\n\n.logUser {\n  margin-bottom: 0.5rem;\n  font-size: 0.9rem;\n}\n\n.logContent {\n  background-color: #f1f3f5;\n  padding: 0.5rem;\n  border-radius: 4px;\n  font-size: 0.9rem;\n}\n\n.originalContent {\n  margin-bottom: 0.5rem;\n}\n\n.originalContent strong,\n.newContent strong {\n  color: #495057;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"technical-challenges",children:"Technical Challenges"}),"\n",(0,o.jsx)(n.h3,{id:"deciding-what-to-log",children:"Deciding What to Log"}),"\n",(0,o.jsx)(n.p,{children:"I had to think carefully about what information to include in the logs. Too much, and it would be unwieldy; too little, and it wouldn't be useful. I settled on:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Who made the change"}),"\n",(0,o.jsx)(n.li,{children:"When it happened"}),"\n",(0,o.jsx)(n.li,{children:"The original content"}),"\n",(0,o.jsx)(n.li,{children:"The new content (for edits)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This gives admins enough context without overwhelming them with details."}),"\n",(0,o.jsx)(n.h3,{id:"soft-deletes-vs-hard-deletes",children:"Soft Deletes vs. Hard Deletes"}),"\n",(0,o.jsx)(n.p,{children:"I went with soft deletes (marking messages as deleted rather than actually removing them) for a few reasons:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"It preserves the conversation flow"}),"\n",(0,o.jsx)(n.li,{children:"It allows for potential message recovery"}),"\n",(0,o.jsx)(n.li,{children:"It's consistent with how other chat apps handle deleted messages"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,o.jsx)(n.p,{children:"I wanted to make sure that only admins could see the logs. I implemented this at multiple levels:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:'Only showing the "View Logs" button to admins'}),"\n",(0,o.jsxs)(n.li,{children:["Checking admin status before fetching logs in the ",(0,o.jsx)(n.code,{children:"fetchChatLogs"})," function"]}),"\n",(0,o.jsx)(n.li,{children:"Planning to add Firebase security rules to restrict access to the logs collection"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,o.jsx)(n.p,{children:"If I had more time, I'd enhance this feature with:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"More detailed filtering options for logs (by user, action type, date range)"}),"\n",(0,o.jsx)(n.li,{children:"Ability to revert message edits or restore deleted messages"}),"\n",(0,o.jsx)(n.li,{children:"Export logs to CSV/PDF for record-keeping"}),"\n",(0,o.jsx)(n.li,{children:"More detailed admin analytics (message frequency, peak usage times)"}),"\n",(0,o.jsx)(n.li,{children:"Additional log types (user joins/leaves, file uploads, etc.)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Working on this feature has taught me a lot about balancing transparency and privacy. While we want to track changes for moderation purposes, we also need to respect user privacy and not log unnecessary information."})]})}function g(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var s=t(6540);const o={},a=s.createContext(o);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);