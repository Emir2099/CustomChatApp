"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[9900],{8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>i});var r=s(6540);const t={},o=r.createContext(t);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(o.Provider,{value:n},e.children)}},9318:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Features/chat-groups-management","title":"Chat Groups Management","description":"Implementing robust group chat functionality was a priority feature for this application. I wanted to create a flexible system that would support both casual and professional use cases with proper admin controls.","source":"@site/docs-source/Features/chat-groups-management.md","sourceDirName":"Features","slug":"/Features/chat-groups-management","permalink":"/CustomChatApp/docs/Features/chat-groups-management","draft":false,"unlisted":false,"editUrl":"https://github.com/Emir2099/CustomChatApp/docs-source/Features/chat-groups-management.md","tags":[],"version":"current","lastUpdatedAt":1747596452000,"sidebarPosition":17,"frontMatter":{"sidebar_position":17},"sidebar":"tutorialSidebar","previous":{"title":"User Presence System","permalink":"/CustomChatApp/docs/Features/user-presence-system"},"next":{"title":"Emoji/Reaction System","permalink":"/CustomChatApp/docs/Features/emoji-reaction-system"}}');var t=s(4848),o=s(8453);const a={sidebar_position:17},i="Chat Groups Management",u={},l=[{value:"Group Creation and Configuration",id:"group-creation-and-configuration",level:2},{value:"Group Management Context",id:"group-management-context",level:2},{value:"Member Management",id:"member-management",level:2},{value:"Group Settings Management",id:"group-settings-management",level:2},{value:"Technical Challenges",id:"technical-challenges",level:2},{value:"Permission System",id:"permission-system",level:3},{value:"Managing Group Data Consistency",id:"managing-group-data-consistency",level:3},{value:"Database Transactions",id:"database-transactions",level:3},{value:"Future Improvements",id:"future-improvements",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chat-groups-management",children:"Chat Groups Management"})}),"\n",(0,t.jsx)(n.p,{children:"Implementing robust group chat functionality was a priority feature for this application. I wanted to create a flexible system that would support both casual and professional use cases with proper admin controls."}),"\n",(0,t.jsx)(n.h2,{id:"group-creation-and-configuration",children:"Group Creation and Configuration"}),"\n",(0,t.jsx)(n.p,{children:"I built a streamlined UI for creating and configuring chat groups:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'// src/components/groups/CreateGroupModal.jsx\nfunction CreateGroupModal({ isOpen, onClose }) {\n  const [groupName, setGroupName] = useState("");\n  const [groupDescription, setGroupDescription] = useState("");\n  const [selectedUsers, setSelectedUsers] = useState([]);\n  const [isPublic, setIsPublic] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  const { createGroup } = useGroups();\n  const { currentUser } = useAuth();\n  const { users } = useUsers();\n  \n  // Filter out the current user from available users\n  const availableUsers = useMemo(() => {\n    return Object.values(users).filter(user => user.uid !== currentUser?.uid);\n  }, [users, currentUser]);\n  \n  const handleUserSelect = (userId) => {\n    setSelectedUsers(prev => {\n      if (prev.includes(userId)) {\n        return prev.filter(id => id !== userId);\n      } else {\n        return [...prev, userId];\n      }\n    });\n  };\n  \n  const handleCreateGroup = async () => {\n    if (!groupName.trim()) {\n      setError("Please enter a group name");\n      return;\n    }\n    \n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      // Add current user as member and admin\n      const members = {\n        [currentUser.uid]: {\n          role: \'admin\',\n          joinedAt: Date.now()\n        }\n      };\n      \n      // Add selected users as members\n      selectedUsers.forEach(userId => {\n        members[userId] = {\n          role: \'member\',\n          joinedAt: Date.now()\n        };\n      });\n      \n      await createGroup({\n        name: groupName.trim(),\n        description: groupDescription.trim(),\n        isPublic,\n        createdBy: currentUser.uid,\n        createdAt: Date.now(),\n        members\n      });\n      \n      onClose();\n    } catch (err) {\n      console.error("Error creating group:", err);\n      setError("Failed to create group. Please try again.");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  return (\n    <Modal isOpen={isOpen} onClose={onClose}>\n      <div className={styles.modalContent}>\n        <h2>Create New Group</h2>\n        \n        {error && <div className={styles.errorMessage}>{error}</div>}\n        \n        <div className={styles.formGroup}>\n          <label htmlFor="groupName">Group Name</label>\n          <input\n            id="groupName"\n            type="text"\n            value={groupName}\n            onChange={(e) => setGroupName(e.target.value)}\n            placeholder="Enter group name"\n            className={styles.input}\n          />\n        </div>\n        \n        <div className={styles.formGroup}>\n          <label htmlFor="groupDescription">Description (optional)</label>\n          <textarea\n            id="groupDescription"\n            value={groupDescription}\n            onChange={(e) => setGroupDescription(e.target.value)}\n            placeholder="Enter group description"\n            className={styles.textarea}\n          />\n        </div>\n        \n        <div className={styles.formGroup}>\n          <label className={styles.checkboxLabel}>\n            <input\n              type="checkbox"\n              checked={isPublic}\n              onChange={() => setIsPublic(!isPublic)}\n              className={styles.checkbox}\n            />\n            Make this group public (anyone can join)\n          </label>\n        </div>\n        \n        <div className={styles.userSelectionSection}>\n          <h3>Add Members</h3>\n          <div className={styles.userList}>\n            {availableUsers.length === 0 ? (\n              <div className={styles.emptyState}>No users available</div>\n            ) : (\n              availableUsers.map(user => (\n                <div \n                  key={user.uid}\n                  className={`\n                    ${styles.userItem} \n                    ${selectedUsers.includes(user.uid) ? styles.selected : \'\'}\n                  `}\n                  onClick={() => handleUserSelect(user.uid)}\n                >\n                  <UserAvatar userId={user.uid} size="small" />\n                  <span>{user.displayName}</span>\n                  \n                  {selectedUsers.includes(user.uid) && (\n                    <CheckIcon className={styles.checkIcon} />\n                  )}\n                </div>\n              ))\n            )}\n          </div>\n        </div>\n        \n        <div className={styles.modalActions}>\n          <button \n            onClick={onClose} \n            className={styles.cancelButton}\n            disabled={isLoading}\n          >\n            Cancel\n          </button>\n          \n          <button \n            onClick={handleCreateGroup} \n            className={styles.createButton}\n            disabled={isLoading || !groupName.trim()}\n          >\n            {isLoading ? \'Creating...\' : \'Create Group\'}\n          </button>\n        </div>\n      </div>\n    </Modal>\n  );\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"group-management-context",children:"Group Management Context"}),"\n",(0,t.jsx)(n.p,{children:"To manage group operations throughout the app, I created a dedicated context:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'// src/contexts/GroupsContext.jsx\nconst GroupsContext = createContext();\n\nexport function GroupsProvider({ children }) {\n  const [groups, setGroups] = useState({});\n  const [userGroups, setUserGroups] = useState([]);\n  const [loading, setLoading] = useState(true);\n  \n  const { currentUser } = useAuth();\n  \n  // Load user\'s groups\n  useEffect(() => {\n    if (!currentUser) {\n      setGroups({});\n      setUserGroups([]);\n      setLoading(false);\n      return;\n    }\n    \n    setLoading(true);\n    \n    const userGroupsRef = ref(db, `userGroups/${currentUser.uid}`);\n    \n    const handleUserGroups = async (snapshot) => {\n      if (!snapshot.exists()) {\n        setUserGroups([]);\n        setGroups({});\n        setLoading(false);\n        return;\n      }\n      \n      const userGroupsData = snapshot.val();\n      const groupIds = Object.keys(userGroupsData);\n      \n      setUserGroups(groupIds);\n      \n      // Fetch detailed group data\n      const groupsData = {};\n      \n      for (const groupId of groupIds) {\n        try {\n          const groupSnapshot = await get(ref(db, `groups/${groupId}`));\n          \n          if (groupSnapshot.exists()) {\n            groupsData[groupId] = {\n              id: groupId,\n              ...groupSnapshot.val()\n            };\n          }\n        } catch (err) {\n          console.error(`Error loading group ${groupId}:`, err);\n        }\n      }\n      \n      setGroups(groupsData);\n      setLoading(false);\n    };\n    \n    onValue(userGroupsRef, handleUserGroups);\n    \n    return () => off(userGroupsRef);\n  }, [currentUser]);\n  \n  // Create a new group\n  const createGroup = async (groupData) => {\n    if (!currentUser) throw new Error("You must be signed in");\n    \n    // Create group in database\n    const groupsRef = ref(db, \'groups\');\n    const newGroupRef = push(groupsRef);\n    const groupId = newGroupRef.key;\n    \n    await set(newGroupRef, groupData);\n    \n    // Add group to each member\'s groups list\n    const memberUpdates = {};\n    \n    Object.keys(groupData.members).forEach(userId => {\n      memberUpdates[`userGroups/${userId}/${groupId}`] = true;\n    });\n    \n    await update(ref(db), memberUpdates);\n    \n    // Create a chat for the group\n    const chatRef = ref(db, `chats/${groupId}`);\n    \n    await set(chatRef, {\n      name: groupData.name,\n      isGroup: true,\n      createdAt: groupData.createdAt,\n      createdBy: groupData.createdBy,\n      participants: Object.keys(groupData.members).reduce((acc, userId) => {\n        acc[userId] = {\n          joinedAt: groupData.members[userId].joinedAt\n        };\n        return acc;\n      }, {})\n    });\n    \n    return groupId;\n  };\n  \n  // Join a group\n  const joinGroup = async (groupId) => {\n    if (!currentUser) throw new Error("You must be signed in");\n    if (!groupId) throw new Error("Group ID is required");\n    \n    // Get group data to verify if it\'s public\n    const groupRef = ref(db, `groups/${groupId}`);\n    const groupSnapshot = await get(groupRef);\n    \n    if (!groupSnapshot.exists()) {\n      throw new Error("Group not found");\n    }\n    \n    const groupData = groupSnapshot.val();\n    \n    if (!groupData.isPublic) {\n      throw new Error("This group is private. You need an invitation to join.");\n    }\n    \n    // Add user to group\n    const updates = {\n      [`groups/${groupId}/members/${currentUser.uid}`]: {\n        role: \'member\',\n        joinedAt: Date.now()\n      },\n      [`userGroups/${currentUser.uid}/${groupId}`]: true,\n      [`chats/${groupId}/participants/${currentUser.uid}`]: {\n        joinedAt: Date.now()\n      }\n    };\n    \n    await update(ref(db), updates);\n    \n    // Add system message about user joining\n    const messagesRef = ref(db, `messages/${groupId}`);\n    const newMessageRef = push(messagesRef);\n    \n    await set(newMessageRef, {\n      type: \'system\',\n      content: `${currentUser.displayName} joined the group`,\n      timestamp: Date.now()\n    });\n    \n    return groupId;\n  };\n  \n  // Leave group\n  const leaveGroup = async (groupId) => {\n    if (!currentUser) throw new Error("You must be signed in");\n    \n    // Check if user is the last admin\n    const groupRef = ref(db, `groups/${groupId}`);\n    const groupSnapshot = await get(groupRef);\n    \n    if (!groupSnapshot.exists()) {\n      throw new Error("Group not found");\n    }\n    \n    const groupData = groupSnapshot.val();\n    \n    // Count admins\n    let adminCount = 0;\n    let isUserAdmin = false;\n    \n    Object.entries(groupData.members || {}).forEach(([userId, memberData]) => {\n      if (memberData.role === \'admin\') {\n        adminCount++;\n        if (userId === currentUser.uid) {\n          isUserAdmin = true;\n        }\n      }\n    });\n    \n    // If user is the only admin, they can\'t leave\n    if (isUserAdmin && adminCount === 1) {\n      throw new Error("You are the only admin. Please promote another member to admin before leaving.");\n    }\n    \n    // Remove user from group\n    const updates = {\n      [`groups/${groupId}/members/${currentUser.uid}`]: null,\n      [`userGroups/${currentUser.uid}/${groupId}`]: null,\n      [`chats/${groupId}/participants/${currentUser.uid}`]: null\n    };\n    \n    await update(ref(db), updates);\n    \n    // Add system message about user leaving\n    const messagesRef = ref(db, `messages/${groupId}`);\n    const newMessageRef = push(messagesRef);\n    \n    await set(newMessageRef, {\n      type: \'system\',\n      content: `${currentUser.displayName} left the group`,\n      timestamp: Date.now()\n    });\n  };\n  \n  // Update group settings\n  const updateGroup = async (groupId, updates) => {\n    if (!currentUser) throw new Error("You must be signed in");\n    \n    // Ensure user is an admin\n    const groupRef = ref(db, `groups/${groupId}`);\n    const groupSnapshot = await get(groupRef);\n    \n    if (!groupSnapshot.exists()) {\n      throw new Error("Group not found");\n    }\n    \n    const groupData = groupSnapshot.val();\n    \n    if (!groupData.members[currentUser.uid] || \n        groupData.members[currentUser.uid].role !== \'admin\') {\n      throw new Error("Only admins can update group settings");\n    }\n    \n    // Don\'t allow updating members through this function\n    const sanitizedUpdates = { ...updates };\n    delete sanitizedUpdates.members;\n    \n    await update(groupRef, sanitizedUpdates);\n    \n    // If name was updated, also update chat name\n    if (updates.name) {\n      await update(ref(db, `chats/${groupId}`), {\n        name: updates.name\n      });\n    }\n  };\n  \n  return (\n    <GroupsContext.Provider value={{\n      groups,\n      userGroups,\n      loading,\n      createGroup,\n      joinGroup,\n      leaveGroup,\n      updateGroup,\n      getGroupById: (groupId) => groups[groupId] || null,\n    }}>\n      {children}\n    </GroupsContext.Provider>\n  );\n}\n\nexport const useGroups = () => useContext(GroupsContext);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"member-management",children:"Member Management"}),"\n",(0,t.jsx)(n.p,{children:"I implemented comprehensive controls for adding, removing, and managing group members:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'// src/components/groups/GroupMembersTab.jsx\nfunction GroupMembersTab({ group }) {\n  const [inviteModalOpen, setInviteModalOpen] = useState(false);\n  const { updateMemberRole, removeMember } = useGroups();\n  const { currentUser } = useAuth();\n  \n  const isAdmin = useMemo(() => {\n    if (!group || !currentUser) return false;\n    const currentMember = group.members[currentUser.uid];\n    return currentMember && currentMember.role === \'admin\';\n  }, [group, currentUser]);\n  \n  const members = useMemo(() => {\n    if (!group?.members) return [];\n    \n    return Object.entries(group.members)\n      .map(([userId, data]) => ({\n        userId,\n        ...data\n      }))\n      .sort((a, b) => {\n        // Admins first, then sort by join date\n        if (a.role === \'admin\' && b.role !== \'admin\') return -1;\n        if (a.role !== \'admin\' && b.role === \'admin\') return 1;\n        return a.joinedAt - b.joinedAt;\n      });\n  }, [group?.members]);\n  \n  const handleRoleChange = async (userId, newRole) => {\n    if (!isAdmin) return;\n    \n    try {\n      await updateMemberRole(group.id, userId, newRole);\n    } catch (err) {\n      console.error("Error updating member role:", err);\n      // Show error notification\n    }\n  };\n  \n  const handleRemoveMember = async (userId) => {\n    if (!isAdmin) return;\n    \n    // Confirm before removing\n    if (!window.confirm("Are you sure you want to remove this member?")) {\n      return;\n    }\n    \n    try {\n      await removeMember(group.id, userId);\n    } catch (err) {\n      console.error("Error removing member:", err);\n      // Show error notification\n    }\n  };\n  \n  return (\n    <div className={styles.membersTab}>\n      <div className={styles.tabHeader}>\n        <h3>Members ({members.length})</h3>\n        \n        {isAdmin && (\n          <button \n            className={styles.inviteButton}\n            onClick={() => setInviteModalOpen(true)}\n          >\n            Invite Members\n          </button>\n        )}\n      </div>\n      \n      <div className={styles.membersList}>\n        {members.map((member) => (\n          <div key={member.userId} className={styles.memberItem}>\n            <div className={styles.memberInfo}>\n              <UserAvatar userId={member.userId} size="small" />\n              \n              <div className={styles.memberDetails}>\n                <div className={styles.memberName}>\n                  <UserName userId={member.userId} />\n                  \n                  {member.role === \'admin\' && (\n                    <span className={styles.adminBadge}>Admin</span>\n                  )}\n                </div>\n                \n                <div className={styles.memberSince}>\n                  Member since {formatDate(member.joinedAt)}\n                </div>\n              </div>\n            </div>\n            \n            {isAdmin && member.userId !== currentUser.uid && (\n              <div className={styles.memberActions}>\n                <select\n                  value={member.role}\n                  onChange={(e) => handleRoleChange(member.userId, e.target.value)}\n                  className={styles.roleSelect}\n                >\n                  <option value="member">Member</option>\n                  <option value="admin">Admin</option>\n                </select>\n                \n                <button\n                  onClick={() => handleRemoveMember(member.userId)}\n                  className={styles.removeButton}\n                  aria-label="Remove member"\n                  title="Remove member"\n                >\n                  <RemoveIcon />\n                </button>\n              </div>\n            )}\n          </div>\n        ))}\n      </div>\n      \n      {inviteModalOpen && (\n        <InviteMembersModal \n          isOpen={inviteModalOpen}\n          onClose={() => setInviteModalOpen(false)}\n          groupId={group.id}\n          existingMembers={Object.keys(group.members)}\n        />\n      )}\n    </div>\n  );\n}\n\n// src/components/groups/InviteMembersModal.jsx\nfunction InviteMembersModal({ isOpen, onClose, groupId, existingMembers }) {\n  const [selectedUsers, setSelectedUsers] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [searchQuery, setSearchQuery] = useState("");\n  \n  const { inviteToGroup } = useGroups();\n  const { users } = useUsers();\n  \n  // Filter available users (not already in the group)\n  const availableUsers = useMemo(() => {\n    return Object.values(users)\n      .filter(user => !existingMembers.includes(user.uid))\n      .filter(user => {\n        if (!searchQuery.trim()) return true;\n        return user.displayName.toLowerCase().includes(searchQuery.toLowerCase());\n      });\n  }, [users, existingMembers, searchQuery]);\n  \n  const handleUserSelect = (userId) => {\n    setSelectedUsers(prev => {\n      if (prev.includes(userId)) {\n        return prev.filter(id => id !== userId);\n      } else {\n        return [...prev, userId];\n      }\n    });\n  };\n  \n  const handleInviteUsers = async () => {\n    if (selectedUsers.length === 0) return;\n    \n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      await inviteToGroup(groupId, selectedUsers);\n      onClose();\n    } catch (err) {\n      console.error("Error inviting members:", err);\n      setError("Failed to invite members. Please try again.");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  return (\n    <Modal isOpen={isOpen} onClose={onClose}>\n      <div className={styles.modalContent}>\n        <h2>Invite Members</h2>\n        \n        {error && <div className={styles.errorMessage}>{error}</div>}\n        \n        <div className={styles.searchBox}>\n          <input\n            type="text"\n            placeholder="Search users..."\n            value={searchQuery}\n            onChange={(e) => setSearchQuery(e.target.value)}\n            className={styles.searchInput}\n          />\n        </div>\n        \n        <div className={styles.userList}>\n          {availableUsers.length === 0 ? (\n            <div className={styles.emptyState}>No users found</div>\n          ) : (\n            availableUsers.map(user => (\n              <div \n                key={user.uid}\n                className={`\n                  ${styles.userItem} \n                  ${selectedUsers.includes(user.uid) ? styles.selected : \'\'}\n                `}\n                onClick={() => handleUserSelect(user.uid)}\n              >\n                <UserAvatar userId={user.uid} size="small" />\n                <span>{user.displayName}</span>\n                \n                {selectedUsers.includes(user.uid) && (\n                  <CheckIcon className={styles.checkIcon} />\n                )}\n              </div>\n            ))\n          )}\n        </div>\n        \n        <div className={styles.modalActions}>\n          <button \n            onClick={onClose} \n            className={styles.cancelButton}\n            disabled={isLoading}\n          >\n            Cancel\n          </button>\n          \n          <button \n            onClick={handleInviteUsers} \n            className={styles.inviteButton}\n            disabled={isLoading || selectedUsers.length === 0}\n          >\n            {isLoading ? \'Inviting...\' : `Invite (${selectedUsers.length})`}\n          </button>\n        </div>\n      </div>\n    </Modal>\n  );\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"group-settings-management",children:"Group Settings Management"}),"\n",(0,t.jsx)(n.p,{children:"I built a comprehensive interface for managing group settings:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'// src/components/groups/GroupSettingsTab.jsx\nfunction GroupSettingsTab({ group }) {\n  const [name, setName] = useState(group?.name || "");\n  const [description, setDescription] = useState(group?.description || "");\n  const [isPublic, setIsPublic] = useState(group?.isPublic || false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [success, setSuccess] = useState(false);\n  const [error, setError] = useState(null);\n  \n  const { updateGroup, leaveGroup, deleteGroup } = useGroups();\n  const { currentUser } = useAuth();\n  const navigate = useNavigate();\n  \n  const isAdmin = useMemo(() => {\n    if (!group || !currentUser) return false;\n    const currentMember = group.members[currentUser.uid];\n    return currentMember && currentMember.role === \'admin\';\n  }, [group, currentUser]);\n  \n  // Update form when group changes\n  useEffect(() => {\n    if (group) {\n      setName(group.name || "");\n      setDescription(group.description || "");\n      setIsPublic(group.isPublic || false);\n    }\n  }, [group]);\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    \n    if (!isAdmin) return;\n    if (!name.trim()) {\n      setError("Group name is required");\n      return;\n    }\n    \n    setIsLoading(true);\n    setError(null);\n    setSuccess(false);\n    \n    try {\n      await updateGroup(group.id, {\n        name: name.trim(),\n        description: description.trim(),\n        isPublic\n      });\n      \n      setSuccess(true);\n      \n      // Clear success message after 3 seconds\n      setTimeout(() => setSuccess(false), 3000);\n    } catch (err) {\n      console.error("Error updating group:", err);\n      setError("Failed to update group settings");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  const handleLeaveGroup = async () => {\n    if (!window.confirm("Are you sure you want to leave this group?")) {\n      return;\n    }\n    \n    try {\n      await leaveGroup(group.id);\n      navigate(\'/\'); // Redirect to home\n    } catch (err) {\n      console.error("Error leaving group:", err);\n      setError(err.message);\n    }\n  };\n  \n  const handleDeleteGroup = async () => {\n    if (!isAdmin) return;\n    \n    if (!window.confirm("Are you sure you want to delete this group? This action cannot be undone.")) {\n      return;\n    }\n    \n    try {\n      await deleteGroup(group.id);\n      navigate(\'/\'); // Redirect to home\n    } catch (err) {\n      console.error("Error deleting group:", err);\n      setError("Failed to delete group");\n    }\n  };\n  \n  if (!group) return null;\n  \n  return (\n    <div className={styles.settingsTab}>\n      {isAdmin ? (\n        <form onSubmit={handleSubmit} className={styles.settingsForm}>\n          <h3>Group Settings</h3>\n          \n          {error && <div className={styles.errorMessage}>{error}</div>}\n          {success && <div className={styles.successMessage}>Settings updated successfully</div>}\n          \n          <div className={styles.formGroup}>\n            <label htmlFor="groupName">Group Name</label>\n            <input\n              id="groupName"\n              type="text"\n              value={name}\n              onChange={(e) => setName(e.target.value)}\n              placeholder="Enter group name"\n              className={styles.input}\n              required\n            />\n          </div>\n          \n          <div className={styles.formGroup}>\n            <label htmlFor="groupDescription">Description</label>\n            <textarea\n              id="groupDescription"\n              value={description}\n              onChange={(e) => setDescription(e.target.value)}\n              placeholder="Enter group description"\n              className={styles.textarea}\n            />\n          </div>\n          \n          <div className={styles.formGroup}>\n            <label className={styles.checkboxLabel}>\n              <input\n                type="checkbox"\n                checked={isPublic}\n                onChange={() => setIsPublic(!isPublic)}\n                className={styles.checkbox}\n              />\n              Public group (anyone can join)\n            </label>\n          </div>\n          \n          <div className={styles.formActions}>\n            <button \n              type="submit"\n              className={styles.saveButton}\n              disabled={isLoading}\n            >\n              {isLoading ? \'Saving...\' : \'Save Changes\'}\n            </button>\n          </div>\n        </form>\n      ) : (\n        <div className={styles.viewOnlySettings}>\n          <h3>Group Info</h3>\n          \n          <div className={styles.infoItem}>\n            <strong>Name:</strong> {group.name}\n          </div>\n          \n          {group.description && (\n            <div className={styles.infoItem}>\n              <strong>Description:</strong> {group.description}\n            </div>\n          )}\n          \n          <div className={styles.infoItem}>\n            <strong>Type:</strong> {group.isPublic ? \'Public\' : \'Private\'} Group\n          </div>\n          \n          <div className={styles.infoItem}>\n            <strong>Created:</strong> {formatDate(group.createdAt)}\n          </div>\n        </div>\n      )}\n      \n      <div className={styles.dangerZone}>\n        <h3>Danger Zone</h3>\n        \n        <button\n          onClick={handleLeaveGroup}\n          className={styles.leaveButton}\n        >\n          Leave Group\n        </button>\n        \n        {isAdmin && (\n          <button\n            onClick={handleDeleteGroup}\n            className={styles.deleteButton}\n          >\n            Delete Group\n          </button>\n        )}\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"technical-challenges",children:"Technical Challenges"}),"\n",(0,t.jsx)(n.h3,{id:"permission-system",children:"Permission System"}),"\n",(0,t.jsx)(n.p,{children:"Implementing a robust permission system for group management was challenging:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"// src/utils/permissions.js\nexport const GroupPermissions = {\n  VIEW: 'view',\n  SEND_MESSAGES: 'send_messages',\n  INVITE_MEMBERS: 'invite_members',\n  REMOVE_MEMBERS: 'remove_members',\n  EDIT_SETTINGS: 'edit_settings',\n  MANAGE_ROLES: 'manage_roles',\n  DELETE_GROUP: 'delete_group'\n};\n\nexport const RolePermissions = {\n  admin: [\n    GroupPermissions.VIEW,\n    GroupPermissions.SEND_MESSAGES,\n    GroupPermissions.INVITE_MEMBERS,\n    GroupPermissions.REMOVE_MEMBERS,\n    GroupPermissions.EDIT_SETTINGS,\n    GroupPermissions.MANAGE_ROLES,\n    GroupPermissions.DELETE_GROUP\n  ],\n  moderator: [\n    GroupPermissions.VIEW,\n    GroupPermissions.SEND_MESSAGES,\n    GroupPermissions.INVITE_MEMBERS,\n    GroupPermissions.REMOVE_MEMBERS\n  ],\n  member: [\n    GroupPermissions.VIEW,\n    GroupPermissions.SEND_MESSAGES\n  ]\n};\n\n// Helper to check permissions\nexport const hasPermission = (user, group, permission) => {\n  // Not a member of the group\n  if (!user || !group || !group.members || !group.members[user.uid]) {\n    // Special case: public groups are viewable by anyone\n    if (permission === GroupPermissions.VIEW && group.isPublic) {\n      return true;\n    }\n    return false;\n  }\n  \n  const userRole = group.members[user.uid].role || 'member';\n  return RolePermissions[userRole].includes(permission);\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"managing-group-data-consistency",children:"Managing Group Data Consistency"}),"\n",(0,t.jsx)(n.p,{children:"Ensuring data consistency across chats and groups was complex:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'// Adding security rules to enforce consistency\n// firebase-database-rules.json\n{\n  "rules": {\n    "groups": {\n      "$groupId": {\n        // Only admins can update group settings\n        ".write": "auth !== null && \n                  data.child(\'members\').child(auth.uid).child(\'role\').val() === \'admin\'",\n        \n        // Group members can update specific paths like messages\n        "members": {\n          ".write": "auth !== null && \n                    (data.child(auth.uid).exists() || \n                     newData.child(auth.uid).exists())"\n        }\n      }\n    },\n    "chats": {\n      "$chatId": {\n        // Enforce consistent participants between chats and groups\n        ".validate": "!data.child(\'isGroup\').exists() || \n                      !data.child(\'isGroup\').val() || \n                      root.child(\'groups\').child($chatId).exists()",\n        \n        "participants": {\n          // For group chats, participant list must match group members\n          ".validate": "!root.child(\'groups\').child($chatId).exists() || \n                        root.child(\'groups\').child($chatId).child(\'members\').child(auth.uid).exists()"\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"database-transactions",children:"Database Transactions"}),"\n",(0,t.jsx)(n.p,{children:"For critical operations like role changes, I needed to ensure atomicity:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"// In GroupsContext.jsx\nconst updateMemberRole = async (groupId, userId, newRole) => {\n  if (!currentUser) throw new Error(\"You must be signed in\");\n  \n  // Get reference to member's role\n  const memberRoleRef = ref(db, `groups/${groupId}/members/${userId}/role`);\n  \n  // Run this as a transaction to prevent race conditions\n  return runTransaction(memberRoleRef, (currentRole) => {\n    // Validate current user is admin and target role is valid\n    if (!isUserGroupAdmin(groupId) || !['admin', 'moderator', 'member'].includes(newRole)) {\n      return; // Abort transaction\n    }\n    \n    // If making someone admin, ensure another admin exists if currentUser is demoting themselves\n    if (userId === currentUser.uid && currentRole === 'admin' && newRole !== 'admin') {\n      // Count other admins to ensure we're not removing the last admin\n      let otherAdmins = 0;\n      const groupMembers = groups[groupId]?.members || {};\n      \n      Object.entries(groupMembers).forEach(([memberId, memberData]) => {\n        if (memberId !== currentUser.uid && memberData.role === 'admin') {\n          otherAdmins++;\n        }\n      });\n      \n      if (otherAdmins === 0) {\n        throw new Error(\"Cannot demote yourself as you are the only admin\");\n      }\n    }\n    \n    return newRole;\n  });\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,t.jsx)(n.p,{children:"I have several ideas to enhance group management:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Role Customization"})," - Allow group creators to define custom roles with granular permissions."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Subgroups"})," - Add support for creating subgroups within a main group to organize different topics."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Group Templates"})," - Presets for creating common group types (team, class, community, etc.)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Group Activity Reports"})," - Provide admins with insights about member engagement."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Role Assignment Rules"})," - Automatic role assignment based on user activity or criteria."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The group management system has become one of the most used features in the application, especially for team and community use cases. The robust permission system ensures that everyone gets the right level of access, while the admin tools provide full control over group dynamics."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);