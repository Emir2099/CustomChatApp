"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2161],{8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}},8878:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"api-reference","title":"API Reference","description":"I built this chat application using Firebase\'s Realtime Database as the backend. Here\'s a detailed reference of the API structure and the key functions I implemented.","source":"@site/docs-source/api-reference.md","sourceDirName":".","slug":"/api-reference","permalink":"/CustomChatApp/docs/api-reference","draft":false,"unlisted":false,"editUrl":"https://github.com/Emir2099/CustomChatApp/docs-source/api-reference.md","tags":[],"version":"current","lastUpdatedAt":1747596735000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Troubleshooting Guide","permalink":"/CustomChatApp/docs/troubleshooting"},"next":{"title":"Performance Optimization","permalink":"/CustomChatApp/docs/performance-optimization"}}');var a=t(4848),r=t(8453);const i={sidebar_position:7},o="API Reference",c={},l=[{value:"Database Structure",id:"database-structure",level:2},{value:"Users Collection",id:"users-collection",level:3},{value:"Chats Collection",id:"chats-collection",level:3},{value:"Messages Collection",id:"messages-collection",level:3},{value:"User Chats Collection",id:"user-chats-collection",level:3},{value:"Typing Indicators Collection",id:"typing-indicators-collection",level:3},{value:"Logs Collection",id:"logs-collection",level:3},{value:"Core API Functions",id:"core-api-functions",level:2},{value:"Authentication",id:"authentication",level:3},{value:"Chat Management",id:"chat-management",level:3},{value:"Message Operations",id:"message-operations",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Security Rules",id:"security-rules",level:2},{value:"Rate Limiting",id:"rate-limiting",level:2},{value:"Future API Enhancements",id:"future-api-enhancements",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"api-reference",children:"API Reference"})}),"\n",(0,a.jsx)(n.p,{children:"I built this chat application using Firebase's Realtime Database as the backend. Here's a detailed reference of the API structure and the key functions I implemented."}),"\n",(0,a.jsx)(n.h2,{id:"database-structure",children:"Database Structure"}),"\n",(0,a.jsx)(n.p,{children:"The database is organized into several main collections:"}),"\n",(0,a.jsx)(n.h3,{id:"users-collection",children:"Users Collection"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'/users/{userId}: {\n  "displayName": "John Doe",\n  "email": "john@example.com",\n  "photoURL": "https://example.com/photo.jpg",\n  "bio": "Hello, I\'m John!",\n  "isOnline": true,\n  "lastSeen": 1650120000000,\n  "createdAt": 1649120000000,\n  "isAdmin": false,\n  "blockedUsers": {\n    "userId1": true,\n    "userId2": true\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"chats-collection",children:"Chats Collection"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'/chats/{chatId}: {\n  "type": "private", // or "group"\n  "createdAt": 1649120000000,\n  "updatedAt": 1650120000000,\n  "lastMessageTime": 1650120050000,\n  \n  // For private chats\n  "participants": {\n    "userId1": true,\n    "userId2": true\n  },\n  \n  // For group chats\n  "name": "Project Team",\n  "createdBy": "userId1",\n  "members": {\n    "userId1": {\n      "role": "admin",\n      "joinedAt": 1649120000000\n    },\n    "userId2": {\n      "role": "member",\n      "joinedAt": 1649120010000\n    }\n  },\n  \n  // Last message preview (for both types)\n  "lastMessage": {\n    "content": "Hello everyone!",\n    "sender": "userId1",\n    "senderName": "John Doe",\n    "timestamp": 1650120050000\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"messages-collection",children:"Messages Collection"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'/messages/{chatId}/{messageId}: {\n  "content": "Hello, how are you?",\n  "sender": "userId1",\n  "senderName": "John Doe",\n  "senderPhotoURL": "https://example.com/photo.jpg",\n  "timestamp": 1650120000000,\n  "edited": false,\n  "editedAt": null,\n  "deleted": false,\n  "deletedAt": null,\n  "type": "text", // or "file", "voice"\n  "readBy": {\n    "userId1": 1650120000000,\n    "userId2": 1650120010000\n  },\n  "replyTo": "messageId123", // Optional reference to another message\n  \n  // For file messages\n  "fileName": "document.pdf",\n  "fileSize": 1024000,\n  "fileType": "application/pdf",\n  "fileCategory": "document",\n  "fileData": "base64string...",\n  \n  // For voice messages\n  "voiceData": "base64string...",\n  "duration": 15, // in seconds\n  \n  // Reactions\n  "reactions": {\n    "userId1": "\ud83d\udc4d",\n    "userId2": "\u2764\ufe0f"\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"user-chats-collection",children:"User Chats Collection"}),"\n",(0,a.jsx)(n.p,{children:"This is a mapping between users and their chats for quick access:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'/userChats/{userId}/{chatId}: {\n  "timestamp": 1650120000000,\n  "unreadCount": 5\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"typing-indicators-collection",children:"Typing Indicators Collection"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'/typing/{chatId}/{userId}: {\n  "isTyping": true,\n  "displayName": "John Doe",\n  "timestamp": 1650120000000\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"logs-collection",children:"Logs Collection"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'/logs/{chatId}/{logId}: {\n  "messageId": "messageId123",\n  "type": "EDIT", // or "DELETE"\n  "performedBy": "userId1",\n  "performedByName": "John Doe",\n  "timestamp": 1650120050000,\n  "originalContent": "Hello there",\n  "newContent": "Hello everyone" // Only for EDIT logs\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"core-api-functions",children:"Core API Functions"}),"\n",(0,a.jsx)(n.h3,{id:"authentication",children:"Authentication"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// Sign up a new user\nconst signup = async (email, password, displayName) => {\n  const userCredential = await createUserWithEmailAndPassword(auth, email, password);\n  await updateProfile(userCredential.user, { displayName });\n  await set(ref(db, `users/${userCredential.user.uid}`), {\n    displayName,\n    email,\n    createdAt: serverTimestamp(),\n    lastSeen: serverTimestamp(),\n    isOnline: true\n  });\n  return userCredential.user;\n};\n\n// Sign in an existing user\nconst login = async (email, password) => {\n  return signInWithEmailAndPassword(auth, email, password);\n};\n\n// Sign out\nconst logout = async () => {\n  // Update user status before signing out\n  if (user) {\n    await update(ref(db, `users/${user.uid}`), {\n      isOnline: false,\n      lastSeen: serverTimestamp()\n    });\n  }\n  return signOut(auth);\n};\n\n// Reset password\nconst resetPassword = (email) => {\n  return sendPasswordResetEmail(auth, email);\n};\n\n// Update user profile\nconst updateUserProfile = async (data) => {\n  if (!user) return;\n  \n  // Update Firebase Auth profile\n  await updateProfile(user, {\n    displayName: data.displayName || user.displayName,\n    photoURL: data.photoURL || user.photoURL\n  });\n  \n  // Update database user data\n  await update(ref(db, `users/${user.uid}`), {\n    displayName: data.displayName || user.displayName,\n    photoURL: data.photoURL || user.photoURL,\n    bio: data.bio || null,\n    updatedAt: serverTimestamp()\n  });\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"chat-management",children:"Chat Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// Create a direct chat between two users\nconst createChat = async (otherUserId) => {\n  // Implementation details in ChatContext section\n};\n\n// Create a group chat\nconst createGroupChat = async (name, members) => {\n  // Implementation details in ChatContext section\n};\n\n// Leave a chat\nconst leaveChat = async (chatId) => {\n  if (!chatId || !user?.uid) return false;\n  \n  try {\n    const chatRef = ref(db, `chats/${chatId}`);\n    const snapshot = await get(chatRef);\n    \n    if (!snapshot.exists()) {\n      throw new Error('Chat does not exist');\n    }\n    \n    const chatData = snapshot.val();\n    \n    if (chatData.type === 'private') {\n      // For private chats, remove the chat reference from userChats\n      await set(ref(db, `userChats/${user.uid}/${chatId}`), null);\n    } else if (chatData.type === 'group') {\n      // For group chats, remove the user from members\n      await update(ref(db, `chats/${chatId}/members/${user.uid}`), null);\n      await set(ref(db, `userChats/${user.uid}/${chatId}`), null);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error leaving chat:', error);\n    return false;\n  }\n};\n\n// Update chat metadata (for group chats)\nconst updateChatMeta = async (chatId, data) => {\n  if (!chatId || !user?.uid) return false;\n  \n  try {\n    // Check if user has permission (is admin)\n    const chatRef = ref(db, `chats/${chatId}`);\n    const snapshot = await get(chatRef);\n    \n    if (!snapshot.exists()) {\n      throw new Error('Chat does not exist');\n    }\n    \n    const chatData = snapshot.val();\n    \n    if (\n      chatData.type !== 'group' || \n      !chatData.members?.[user.uid]?.role === 'admin'\n    ) {\n      throw new Error('Not authorized to update this chat');\n    }\n    \n    // Update allowed fields\n    const updates = {};\n    if (data.name) updates.name = data.name;\n    if (data.photoURL) updates.photoURL = data.photoURL;\n    updates.updatedAt = serverTimestamp();\n    \n    await update(chatRef, updates);\n    return true;\n  } catch (error) {\n    console.error('Error updating chat:', error);\n    return false;\n  }\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"message-operations",children:"Message Operations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// Send a text message\nconst sendMessage = async (content, replyToId = null) => {\n  // Implementation details in ChatContext section\n};\n\n// Edit a message\nconst editMessage = async (chatId, messageId, newContent) => {\n  // Implementation details in ChatContext section\n};\n\n// Delete a message\nconst deleteMessage = async (chatId, messageId) => {\n  // Implementation details in ChatContext section\n};\n\n// Mark messages as read\nconst markChatAsRead = async (chatId) => {\n  // Implementation details in ChatContext section\n};\n\n// Add reaction to a message\nconst handleVote = async (chatId, messageId, reaction) => {\n  // Implementation details in ChatContext section\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsx)(n.p,{children:"I implemented comprehensive error handling throughout the application:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// Example of error handling in message sending\ntry {\n  // Send message logic\n} catch (error) {\n  // Check error type\n  if (error.code === 'PERMISSION_DENIED') {\n    // Handle permission errors\n    showToast('You do not have permission to send messages in this chat');\n  } else if (error.code === 'NETWORK_ERROR') {\n    // Handle network errors\n    queueMessageForLaterSending(message);\n    showToast('Message will be sent when you reconnect');\n  } else {\n    // Generic error handling\n    console.error('Error sending message:', error);\n    showToast('Failed to send message. Please try again.');\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(n.p,{children:"When building this API, I focused on several performance aspects:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Pagination"}),": Messages are loaded in batches of 20-50 to avoid loading the entire chat history at once"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Selective Updates"}),": Using Firebase's update() method to modify only specific fields"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Indexing"}),": Ensuring proper indexing in the database for common queries"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimistic UI Updates"}),": Updating the UI before server confirmation to improve perceived performance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Data Denormalization"}),": Strategic duplication of data (like lastMessage in chats) to reduce query complexity"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"security-rules",children:"Security Rules"}),"\n",(0,a.jsx)(n.p,{children:"I implemented Firebase security rules to protect the data:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'// Example Firebase security rules\n{\n  "rules": {\n    "users": {\n      "$uid": {\n        // Users can read any user profile\n        ".read": "auth !== null",\n        // Users can only write to their own profile\n        ".write": "auth !== null && auth.uid === $uid"\n      }\n    },\n    "chats": {\n      "$chatId": {\n        // Users can read chats they are part of\n        ".read": "auth !== null && data.child(\'participants\').hasChild(auth.uid)",\n        // Chat creation and updates\n        ".write": "auth !== null && (\n          // New chat\n          !data.exists() || \n          // Existing chat participant\n          data.child(\'participants\').hasChild(auth.uid) ||\n          // Group chat admin\n          (data.child(\'type\').val() === \'group\' && \n           data.child(\'members\').child(auth.uid).child(\'role\').val() === \'admin\')\n        )"\n      }\n    },\n    "messages": {\n      "$chatId": {\n        // Users can read messages from chats they are part of\n        ".read": "auth !== null && \n                 root.child(\'chats\').child($chatId).child(\'participants\').hasChild(auth.uid)",\n        // Users can write messages to chats they are part of\n        ".write": "auth !== null && \n                  root.child(\'chats\').child($chatId).child(\'participants\').hasChild(auth.uid)"\n      }\n    }\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,a.jsx)(n.p,{children:"To prevent abuse, I implemented rate limiting for certain operations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// Example rate limiting for message sending\nconst sendMessage = async (content, replyToId = null) => {\n  // Check if user has sent too many messages recently\n  const recentMessagesRef = query(\n    ref(db, `messages/${currentChat.id}`),\n    orderByChild('sender'),\n    equalTo(user.uid),\n    limitToLast(10)\n  );\n  \n  const snapshot = await get(recentMessagesRef);\n  \n  if (snapshot.exists()) {\n    const messages = Object.values(snapshot.val());\n    const now = Date.now();\n    const recentCount = messages.filter(msg => \n      now - msg.timestamp < 10000 // Last 10 seconds\n    ).length;\n    \n    if (recentCount >= 5) {\n      throw new Error('You are sending messages too quickly. Please wait a moment.');\n    }\n  }\n  \n  // Continue with sending message\n  // ...\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"future-api-enhancements",children:"Future API Enhancements"}),"\n",(0,a.jsx)(n.p,{children:"I have several ideas for enhancing the API in the future:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"WebSocket Integration"}),": Move from Firebase Realtime Database to a custom WebSocket solution for more control"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"GraphQL API"}),": Implement a GraphQL layer for more efficient data fetching"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Caching Layer"}),": Add a Redis caching layer for frequently accessed data"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Microservices"}),": Split functionality into microservices for better scalability"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Analytics API"}),": Add endpoints for collecting usage statistics and user engagement metrics"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);