"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[149],{4224:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"Features/media-embedding-controls","title":"Media Embedding Controls","description":"I wanted chat admins to have control over how external media is handled in conversations. Some media can be resource-intensive or inappropriate, so I built admin controls to manage what gets embedded.","source":"@site/docs-source/Features/media-embedding-controls.md","sourceDirName":"Features","slug":"/Features/media-embedding-controls","permalink":"/CustomChatApp/docs/Features/media-embedding-controls","draft":false,"unlisted":false,"editUrl":"https://github.com/Emir2099/CustomChatApp/docs-source/Features/media-embedding-controls.md","tags":[],"version":"current","lastUpdatedAt":1747596735000,"sidebarPosition":14,"frontMatter":{"sidebar_position":14},"sidebar":"tutorialSidebar","previous":{"title":"Announcements Feature","permalink":"/CustomChatApp/docs/Features/announcements"},"next":{"title":"Message Search","permalink":"/CustomChatApp/docs/Features/message-search"}}');var a=s(4848),i=s(8453);const r={sidebar_position:14},d="Media Embedding Controls",o={},l=[{value:"How Media Embedding Works",id:"how-media-embedding-works",level:2},{value:"Admin Configuration",id:"admin-configuration",level:2},{value:"Link Detection and Processing",id:"link-detection-and-processing",level:2},{value:"Embed Approval System",id:"embed-approval-system",level:2},{value:"Displaying Embeds",id:"displaying-embeds",level:2},{value:"Metadata Fetching",id:"metadata-fetching",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Technical Challenges",id:"technical-challenges",level:2},{value:"Security Concerns",id:"security-concerns",level:3},{value:"Bandwidth Concerns",id:"bandwidth-concerns",level:3},{value:"Future Improvements",id:"future-improvements",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"media-embedding-controls",children:"Media Embedding Controls"})}),"\n",(0,a.jsx)(n.p,{children:"I wanted chat admins to have control over how external media is handled in conversations. Some media can be resource-intensive or inappropriate, so I built admin controls to manage what gets embedded."}),"\n",(0,a.jsx)(n.h2,{id:"how-media-embedding-works",children:"How Media Embedding Works"}),"\n",(0,a.jsx)(n.p,{children:"When a user sends a link to external content (images, videos, tweets, etc.), my app can either:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Simply display the link as text"}),"\n",(0,a.jsx)(n.li,{children:"Automatically embed rich previews of the content"}),"\n",(0,a.jsx)(n.li,{children:"Let admins review and approve embeds"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"admin-configuration",children:"Admin Configuration"}),"\n",(0,a.jsx)(n.p,{children:"I created a simple but powerful settings panel for chat admins:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// src/components/chat/ChatSettings.jsx - Media embedding section\nfunction MediaEmbeddingSettings() {\n  const [settings, setSettings] = useState({\n    allowImageEmbeds: true,\n    allowVideoEmbeds: false,\n    allowSocialEmbeds: false,\n    requireApproval: true,\n    maxEmbedSize: 2 // in MB\n  });\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  const { currentChat, updateChatSettings } = useChat();\n  \n  // Load current settings when component mounts\n  useEffect(() => {\n    if (!currentChat?.id) return;\n    \n    const fetchSettings = async () => {\n      setIsLoading(true);\n      try {\n        const chatRef = ref(db, `chats/${currentChat.id}`);\n        const snapshot = await get(chatRef);\n        \n        if (snapshot.exists()) {\n          const chatData = snapshot.val();\n          if (chatData.embedSettings) {\n            setSettings({\n              allowImageEmbeds: chatData.embedSettings.allowImageEmbeds ?? true,\n              allowVideoEmbeds: chatData.embedSettings.allowVideoEmbeds ?? false,\n              allowSocialEmbeds: chatData.embedSettings.allowSocialEmbeds ?? false,\n              requireApproval: chatData.embedSettings.requireApproval ?? true,\n              maxEmbedSize: chatData.embedSettings.maxEmbedSize ?? 2\n            });\n          }\n        }\n      } catch (err) {\n        console.error(\'Error loading embed settings:\', err);\n        setError(\'Failed to load embed settings\');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    \n    fetchSettings();\n  }, [currentChat?.id]);\n  \n  const handleSave = async () => {\n    try {\n      await updateChatSettings({\n        embedSettings: settings\n      });\n      \n      // Show success message\n    } catch (err) {\n      // Show error message\n      console.error(\'Error saving embed settings:\', err);\n    }\n  };\n  \n  return (\n    <div className={styles.settingsSection}>\n      <h3>Media Embedding</h3>\n      \n      {isLoading ? (\n        <div>Loading settings...</div>\n      ) : error ? (\n        <div className={styles.error}>{error}</div>\n      ) : (\n        <form onSubmit={(e) => {\n          e.preventDefault();\n          handleSave();\n        }}>\n          <div className={styles.checkboxSetting}>\n            <input\n              type="checkbox"\n              id="allowImageEmbeds"\n              checked={settings.allowImageEmbeds}\n              onChange={(e) => setSettings({\n                ...settings,\n                allowImageEmbeds: e.target.checked\n              })}\n            />\n            <label htmlFor="allowImageEmbeds">\n              Allow image embeds\n            </label>\n          </div>\n          \n          <div className={styles.checkboxSetting}>\n            <input\n              type="checkbox"\n              id="allowVideoEmbeds"\n              checked={settings.allowVideoEmbeds}\n              onChange={(e) => setSettings({\n                ...settings,\n                allowVideoEmbeds: e.target.checked\n              })}\n            />\n            <label htmlFor="allowVideoEmbeds">\n              Allow video embeds\n            </label>\n          </div>\n          \n          <div className={styles.checkboxSetting}>\n            <input\n              type="checkbox"\n              id="allowSocialEmbeds"\n              checked={settings.allowSocialEmbeds}\n              onChange={(e) => setSettings({\n                ...settings,\n                allowSocialEmbeds: e.target.checked\n              })}\n            />\n            <label htmlFor="allowSocialEmbeds">\n              Allow social media embeds\n            </label>\n          </div>\n          \n          <div className={styles.checkboxSetting}>\n            <input\n              type="checkbox"\n              id="requireApproval"\n              checked={settings.requireApproval}\n              onChange={(e) => setSettings({\n                ...settings,\n                requireApproval: e.target.checked\n              })}\n            />\n            <label htmlFor="requireApproval">\n              Require admin approval for embeds\n            </label>\n          </div>\n          \n          <div className={styles.sliderSetting}>\n            <label htmlFor="maxEmbedSize">\n              Maximum embed size: {settings.maxEmbedSize} MB\n            </label>\n            <input\n              type="range"\n              id="maxEmbedSize"\n              min="1"\n              max="10"\n              step="1"\n              value={settings.maxEmbedSize}\n              onChange={(e) => setSettings({\n                ...settings,\n                maxEmbedSize: parseInt(e.target.value)\n              })}\n            />\n          </div>\n          \n          <button \n            type="submit"\n            className={styles.saveButton}\n          >\n            Save Settings\n          </button>\n        </form>\n      )}\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"link-detection-and-processing",children:"Link Detection and Processing"}),"\n",(0,a.jsx)(n.p,{children:"When a user sends a message, I scan it for URLs that might contain embeddable content:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In ChatContext.jsx\nconst processMessage = async (message) => {\n  // Skip processing for non-text messages\n  if (message.type !== 'text' || !message.content) return message;\n  \n  // Get chat embed settings\n  const chatRef = ref(db, `chats/${message.chatId}`);\n  const chatSnapshot = await get(chatRef);\n  \n  if (!chatSnapshot.exists()) return message;\n  \n  const chatData = chatSnapshot.val();\n  const embedSettings = chatData.embedSettings || {\n    allowImageEmbeds: true,\n    allowVideoEmbeds: false,\n    allowSocialEmbeds: false,\n    requireApproval: true,\n    maxEmbedSize: 2\n  };\n  \n  // Skip embed processing if all embeds are disabled\n  if (!embedSettings.allowImageEmbeds && \n      !embedSettings.allowVideoEmbeds &&\n      !embedSettings.allowSocialEmbeds) {\n    return message;\n  }\n  \n  // Extract URLs from message content\n  const urlRegex = /(https?:\\/\\/[^\\s]+)/g;\n  const urls = message.content.match(urlRegex) || [];\n  \n  if (urls.length === 0) return message;\n  \n  // Process the first URL only (to keep things simpler)\n  const url = urls[0];\n  let embedInfo = null;\n  \n  try {\n    // Try to get OG tags and content type\n    embedInfo = await fetchUrlMetadata(url);\n    \n    // Only proceed if we have valid embed info\n    if (embedInfo) {\n      // Determine embed type\n      const isImage = embedInfo.contentType?.startsWith('image/');\n      const isVideo = embedInfo.contentType?.startsWith('video/');\n      const isSocial = embedInfo.siteName?.toLowerCase().includes('twitter') ||\n                       embedInfo.siteName?.toLowerCase().includes('facebook') ||\n                       embedInfo.siteName?.toLowerCase().includes('instagram');\n      \n      // Check if this type of embed is allowed\n      const isAllowed = \n        (isImage && embedSettings.allowImageEmbeds) ||\n        (isVideo && embedSettings.allowVideoEmbeds) ||\n        (isSocial && embedSettings.allowSocialEmbeds);\n      \n      if (isAllowed) {\n        // Add embed info to message\n        message.embed = {\n          ...embedInfo,\n          approved: !embedSettings.requireApproval // Auto-approve if not required\n        };\n      }\n    }\n  } catch (error) {\n    console.error('Error processing URL for embeds:', error);\n  }\n  \n  return message;\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"embed-approval-system",children:"Embed Approval System"}),"\n",(0,a.jsx)(n.p,{children:"For chats where admin approval is required, I built an approval workflow:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In ChatContext.jsx\nconst approveEmbed = async (chatId, messageId) => {\n  if (!chatId || !messageId || !isCurrentUserAdmin()) return false;\n  \n  try {\n    const messageRef = ref(db, `messages/${chatId}/${messageId}`);\n    \n    await update(messageRef, {\n      'embed.approved': true\n    });\n    \n    return true;\n  } catch (error) {\n    console.error('Error approving embed:', error);\n    return false;\n  }\n};\n\nconst rejectEmbed = async (chatId, messageId) => {\n  if (!chatId || !messageId || !isCurrentUserAdmin()) return false;\n  \n  try {\n    const messageRef = ref(db, `messages/${chatId}/${messageId}`);\n    \n    // Remove the embed altogether\n    await update(messageRef, {\n      embed: null\n    });\n    \n    return true;\n  } catch (error) {\n    console.error('Error rejecting embed:', error);\n    return false;\n  }\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"displaying-embeds",children:"Displaying Embeds"}),"\n",(0,a.jsx)(n.p,{children:"Messages with embeds are rendered differently based on their status:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In MessageItem.jsx\nfunction renderEmbed() {\n  if (!message.embed) return null;\n  \n  // Don't show unapproved embeds to non-admins\n  if (!message.embed.approved && !isCurrentUserAdmin()) return null;\n  \n  // For admins, show approval UI if not yet approved\n  if (!message.embed.approved && isCurrentUserAdmin()) {\n    return (\n      <div className={styles.embedPendingApproval}>\n        <div className={styles.embedInfo}>\n          <div className={styles.embedTitle}>{message.embed.title || 'Untitled'}</div>\n          <div className={styles.embedDescription}>{message.embed.description || 'No description'}</div>\n          <div className={styles.embedUrl}>{message.embed.url}</div>\n        </div>\n        \n        <div className={styles.approvalActions}>\n          <button \n            onClick={() => approveEmbed(currentChat.id, message.id)}\n            className={styles.approveButton}\n          >\n            Approve\n          </button>\n          <button \n            onClick={() => rejectEmbed(currentChat.id, message.id)}\n            className={styles.rejectButton}\n          >\n            Reject\n          </button>\n        </div>\n      </div>\n    );\n  }\n  \n  // Approved embeds for everyone\n  if (message.embed.contentType?.startsWith('image/')) {\n    return (\n      <div className={styles.imageEmbed}>\n        <img \n          src={message.embed.url} \n          alt={message.embed.title || 'Image'} \n          className={styles.embedImage}\n          onClick={() => openLightbox(message.embed.url)}\n        />\n      </div>\n    );\n  }\n  \n  if (message.embed.contentType?.startsWith('video/')) {\n    return (\n      <div className={styles.videoEmbed}>\n        <video \n          src={message.embed.url}\n          controls\n          className={styles.embedVideo}\n        />\n      </div>\n    );\n  }\n  \n  // Generic rich embed\n  return (\n    <a \n      href={message.embed.url} \n      target=\"_blank\" \n      rel=\"noopener noreferrer\"\n      className={styles.richEmbed}\n    >\n      {message.embed.image && (\n        <div className={styles.embedImagePreview}>\n          <img \n            src={message.embed.image} \n            alt=\"\"\n            className={styles.embedThumbnail} \n          />\n        </div>\n      )}\n      \n      <div className={styles.embedContent}>\n        <div className={styles.embedTitle}>{message.embed.title || 'Untitled'}</div>\n        <div className={styles.embedDescription}>{message.embed.description || message.embed.url}</div>\n        {message.embed.siteName && (\n          <div className={styles.embedSiteName}>{message.embed.siteName}</div>\n        )}\n      </div>\n    </a>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"metadata-fetching",children:"Metadata Fetching"}),"\n",(0,a.jsx)(n.p,{children:"The heavy lifting is done by the URL metadata service:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// src/utils/embedUtils.js\nexport const fetchUrlMetadata = async (url) => {\n  try {\n    // For security and efficiency, we use our server-side proxy\n    const response = await fetch(`/api/link-metadata?url=${encodeURIComponent(url)}`);\n    \n    if (!response.ok) {\n      throw new Error(`Failed to fetch metadata: ${response.status}`);\n    }\n    \n    const metadata = await response.json();\n    \n    return {\n      url,\n      title: metadata.title,\n      description: metadata.description,\n      siteName: metadata.siteName,\n      image: metadata.image,\n      contentType: metadata.contentType,\n      size: metadata.size // in bytes\n    };\n  } catch (error) {\n    console.error('Error fetching URL metadata:', error);\n    return null;\n  }\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(n.p,{children:"Media embeds can slow down chat performance, so I implemented some optimizations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In ChatArea.jsx\n// Lazy load embeds when scrolling into view\nconst observerRef = useRef(null);\n\nuseEffect(() => {\n  // Set up intersection observer for lazy loading embeds\n  if (!observerRef.current) {\n    observerRef.current = new IntersectionObserver(\n      (entries) => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            const embedContainer = entry.target;\n            const embedId = embedContainer.dataset.embedId;\n            if (embedId) {\n              // Mark embed as visible in state\n              setVisibleEmbeds(prev => ({\n                ...prev,\n                [embedId]: true\n              }));\n              \n              // Stop observing this element\n              observerRef.current.unobserve(embedContainer);\n            }\n          }\n        });\n      },\n      {\n        root: messagesContainerRef.current,\n        rootMargin: '50px',\n        threshold: 0.1\n      }\n    );\n  }\n  \n  return () => {\n    if (observerRef.current) {\n      observerRef.current.disconnect();\n    }\n  };\n}, []);\n\n// In the render function\n{message.embed && (\n  <div \n    className={styles.embedContainer}\n    data-embed-id={message.id}\n    ref={(el) => {\n      if (el && observerRef.current) {\n        observerRef.current.observe(el);\n      }\n    }}\n  >\n    {visibleEmbeds[message.id] ? renderEmbed(message) : (\n      <div className={styles.embedPlaceholder}>\n        Loading embed...\n      </div>\n    )}\n  </div>\n)}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"technical-challenges",children:"Technical Challenges"}),"\n",(0,a.jsx)(n.h3,{id:"security-concerns",children:"Security Concerns"}),"\n",(0,a.jsx)(n.p,{children:"Embedding external content can introduce security vulnerabilities. To mitigate this:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"I sanitize all HTML to prevent XSS attacks"}),"\n",(0,a.jsx)(n.li,{children:"I use a Content-Security-Policy that restricts which domains can load embedded resources"}),"\n",(0,a.jsxs)(n.li,{children:["I add proper ",(0,a.jsx)(n.code,{children:'rel="noopener noreferrer"'})," attributes to external links"]}),"\n",(0,a.jsx)(n.li,{children:"For untrusted content, I restrict what can be embedded to specific types and domains"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In the API route that fetches link metadata\nconst validateUrl = (url) => {\n  try {\n    const parsed = new URL(url);\n    \n    // Check against allowed domains (optional)\n    const allowedDomains = [\n      'youtube.com', 'youtu.be', 'vimeo.com', \n      'imgur.com', 'giphy.com', 'twitter.com'\n    ];\n    \n    const isDomainAllowed = allowedDomains.some(domain => \n      parsed.hostname === domain || \n      parsed.hostname.endsWith(`.${domain}`)\n    );\n    \n    return {\n      isValid: isDomainAllowed,\n      domain: parsed.hostname\n    };\n  } catch (e) {\n    return { isValid: false };\n  }\n};\n\n// Validate URL before fetching metadata\nconst { isValid, domain } = validateUrl(url);\nif (!isValid) {\n  res.status(400).json({ error: 'Invalid or disallowed URL' });\n  return;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"bandwidth-concerns",children:"Bandwidth Concerns"}),"\n",(0,a.jsx)(n.p,{children:"Embedding can consume a lot of bandwidth, especially in active chats. To address this:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"I set reasonable size limits for embeds (usually 2-5MB)"}),"\n",(0,a.jsx)(n.li,{children:"For images, I generate smaller preview thumbnails"}),"\n",(0,a.jsx)(n.li,{children:"I don't auto-load videos; they require a user interaction to play"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,a.jsx)(n.p,{children:"I have several ideas to improve the embedding system in the future:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Custom Embed Templates"})," - Let admins create custom embed designs for specific domains"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Embed Analytics"})," - Track which embeds get the most interaction"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Better Content Type Detection"})," - Improve the accuracy of content type detection"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"More Granular Controls"})," - Allow admins to whitelist/blacklist specific domains"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Inline Preview"})," - Add an optional preview mode that doesn't require clicking links"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The media embedding controls have been really helpful for group chats where different types of content are shared. Admins appreciate having control over what gets embedded, especially in professional or educational contexts."})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>d});var t=s(6540);const a={},i=t.createContext(a);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);