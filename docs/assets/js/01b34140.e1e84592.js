"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[9370],{5917:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>c,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"Features/message-search","title":"Message Search","description":"Adding a robust message search functionality was important to me since it\'s a fundamental feature for any chat application. I wanted users to be able to quickly find past messages without endlessly scrolling.","source":"@site/docs-source/Features/message-search.md","sourceDirName":"Features","slug":"/Features/message-search","permalink":"/CustomChatApp/docs/Features/message-search","draft":false,"unlisted":false,"editUrl":"https://github.com/Emir2099/CustomChatApp/docs-source/Features/message-search.md","tags":[],"version":"current","lastUpdatedAt":1747596735000,"sidebarPosition":15,"frontMatter":{"sidebar_position":15},"sidebar":"tutorialSidebar","previous":{"title":"Media Embedding Controls","permalink":"/CustomChatApp/docs/Features/media-embedding-controls"},"next":{"title":"User Presence System","permalink":"/CustomChatApp/docs/Features/user-presence-system"}}');var a=s(4848),r=s(8453);const c={sidebar_position:15},i="Message Search",l={},o=[{value:"Core Search Functionality",id:"core-search-functionality",level:2},{value:"Search Result Display",id:"search-result-display",level:2},{value:"Search Context Provider",id:"search-context-provider",level:2},{value:"Integration with Chat UI",id:"integration-with-chat-ui",level:2},{value:"Search Optimization",id:"search-optimization",level:2},{value:"Technical Challenges",id:"technical-challenges",level:2},{value:"Large Message Sets",id:"large-message-sets",level:3},{value:"Search Index",id:"search-index",level:3},{value:"Future Improvements",id:"future-improvements",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"message-search",children:"Message Search"})}),"\n",(0,a.jsx)(n.p,{children:"Adding a robust message search functionality was important to me since it's a fundamental feature for any chat application. I wanted users to be able to quickly find past messages without endlessly scrolling."}),"\n",(0,a.jsx)(n.h2,{id:"core-search-functionality",children:"Core Search Functionality"}),"\n",(0,a.jsx)(n.p,{children:"I implemented a search system that allows users to find messages by:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Text content"}),"\n",(0,a.jsx)(n.li,{children:"Sender name"}),"\n",(0,a.jsx)(n.li,{children:"Date range"}),"\n",(0,a.jsx)(n.li,{children:"Media type"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// src/components/search/MessageSearch.jsx\nfunction MessageSearch() {\n  const [searchQuery, setSearchQuery] = useState("");\n  const [searchType, setSearchType] = useState("text");\n  const [dateRange, setDateRange] = useState({ start: null, end: null });\n  const [searchResults, setSearchResults] = useState([]);\n  const [isSearching, setIsSearching] = useState(false);\n  const [error, setError] = useState(null);\n  \n  const { currentChat } = useChat();\n  const { currentUser } = useAuth();\n  \n  const handleSearch = async (e) => {\n    e.preventDefault();\n    if (!searchQuery.trim() && !dateRange.start && !dateRange.end) return;\n    \n    setIsSearching(true);\n    setError(null);\n    \n    try {\n      const chatRef = ref(db, `messages/${currentChat.id}`);\n      let query = chatRef;\n      \n      // Order by timestamp for date filtering\n      if (dateRange.start || dateRange.end) {\n        query = query.orderByChild(\'timestamp\');\n        \n        if (dateRange.start) {\n          query = query.startAt(dateRange.start.getTime());\n        }\n        \n        if (dateRange.end) {\n          query = query.endAt(dateRange.end.getTime());\n        }\n      }\n      \n      const snapshot = await get(query);\n      \n      if (!snapshot.exists()) {\n        setSearchResults([]);\n        setIsSearching(false);\n        return;\n      }\n      \n      const messages = [];\n      snapshot.forEach((child) => {\n        const message = {\n          id: child.key,\n          ...child.val()\n        };\n        messages.push(message);\n      });\n      \n      // Filter by search query text\n      let filteredMessages = messages;\n      \n      if (searchQuery.trim() !== "") {\n        const normalizedQuery = searchQuery.toLowerCase();\n        \n        switch (searchType) {\n          case "text":\n            filteredMessages = messages.filter(message => \n              message.content && \n              message.content.toLowerCase().includes(normalizedQuery)\n            );\n            break;\n            \n          case "sender":\n            filteredMessages = messages.filter(message => \n              message.senderName && \n              message.senderName.toLowerCase().includes(normalizedQuery)\n            );\n            break;\n            \n          case "media":\n            filteredMessages = messages.filter(message =>\n              message.type === \'image\' || \n              message.type === \'video\' || \n              message.type === \'file\' ||\n              (message.embed && message.embed.contentType && \n               message.embed.contentType.startsWith(normalizedQuery))\n            );\n            break;\n            \n          default:\n            break;\n        }\n      }\n      \n      setSearchResults(filteredMessages);\n      \n    } catch (err) {\n      console.error("Error searching messages:", err);\n      setError("Failed to search messages. Please try again.");\n    } finally {\n      setIsSearching(false);\n    }\n  };\n  \n  return (\n    <div className={styles.searchContainer}>\n      <form onSubmit={handleSearch} className={styles.searchForm}>\n        <div className={styles.searchInputs}>\n          <input\n            type="text"\n            placeholder="Search messages..."\n            value={searchQuery}\n            onChange={(e) => setSearchQuery(e.target.value)}\n            className={styles.searchInput}\n          />\n          \n          <select\n            value={searchType}\n            onChange={(e) => setSearchType(e.target.value)}\n            className={styles.searchType}\n          >\n            <option value="text">By Content</option>\n            <option value="sender">By Sender</option>\n            <option value="media">By Media Type</option>\n          </select>\n        </div>\n        \n        <div className={styles.dateFilters}>\n          <div>\n            <label>From:</label>\n            <DatePicker\n              selected={dateRange.start}\n              onChange={date => setDateRange({...dateRange, start: date})}\n              className={styles.datePicker}\n              maxDate={new Date()}\n            />\n          </div>\n          \n          <div>\n            <label>To:</label>\n            <DatePicker\n              selected={dateRange.end}\n              onChange={date => setDateRange({...dateRange, end: date})}\n              className={styles.datePicker}\n              maxDate={new Date()}\n              minDate={dateRange.start}\n            />\n          </div>\n        </div>\n        \n        <button \n          type="submit" \n          className={styles.searchButton}\n          disabled={isSearching}\n        >\n          {isSearching ? \'Searching...\' : \'Search\'}\n        </button>\n      </form>\n      \n      {error && <div className={styles.errorMessage}>{error}</div>}\n      \n      <div className={styles.resultsContainer}>\n        {searchResults.length === 0 && !isSearching ? (\n          <div className={styles.noResults}>No messages found</div>\n        ) : (\n          <div className={styles.resultsList}>\n            {searchResults.map(message => (\n              <SearchResultItem \n                key={message.id} \n                message={message} \n                currentUser={currentUser}\n              />\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"search-result-display",children:"Search Result Display"}),"\n",(0,a.jsx)(n.p,{children:"I created a specialized component to display search results with context:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// src/components/search/SearchResultItem.jsx\nfunction SearchResultItem({ message, currentUser }) {\n  const { navigateToMessage } = useChat();\n  const messageDate = new Date(message.timestamp);\n  \n  // Format the date for display\n  const formattedDate = new Intl.DateTimeFormat('en-US', {\n    month: 'short',\n    day: 'numeric',\n    year: 'numeric',\n    hour: 'numeric',\n    minute: 'numeric',\n  }).format(messageDate);\n  \n  // Highlight the search terms in the message content\n  const highlightMatch = (content, searchTerm) => {\n    if (!searchTerm || !content) return content;\n    \n    const regex = new RegExp(`(${searchTerm})`, 'gi');\n    return content.replace(regex, '<mark>$1</mark>');\n  };\n  \n  // Used when user clicks on a search result\n  const handleNavigateToMessage = () => {\n    navigateToMessage(message.id);\n  };\n  \n  return (\n    <div \n      className={styles.searchResultItem}\n      onClick={handleNavigateToMessage}\n    >\n      <div className={styles.messageHeader}>\n        <span className={styles.senderName}>\n          {message.senderName}\n          {message.senderId === currentUser.uid && \" (you)\"}\n        </span>\n        <span className={styles.messageTime}>{formattedDate}</span>\n      </div>\n      \n      <div className={styles.messageContent}>\n        {message.type === 'text' ? (\n          <div \n            dangerouslySetInnerHTML={{ \n              __html: highlightMatch(message.content) \n            }}\n            className={styles.messageText}\n          />\n        ) : message.type === 'image' ? (\n          <div className={styles.imagePreview}>\n            <img src={message.imageUrl} alt=\"Image\" />\n            <span>Image</span>\n          </div>\n        ) : message.type === 'file' ? (\n          <div className={styles.filePreview}>\n            <span className={styles.fileIcon}>\ud83d\udcc4</span>\n            <span>{message.fileName}</span>\n          </div>\n        ) : (\n          <div className={styles.messageText}>{message.content}</div>\n        )}\n      </div>\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"search-context-provider",children:"Search Context Provider"}),"\n",(0,a.jsx)(n.p,{children:"To make search functionality available throughout the app, I created a dedicated context:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// src/contexts/SearchContext.jsx\nconst SearchContext = createContext();\n\nexport function SearchProvider({ children }) {\n  const [searchOpen, setSearchOpen] = useState(false);\n  const [lastSearch, setLastSearch] = useState({\n    query: \"\",\n    type: \"text\",\n    dateRange: { start: null, end: null }\n  });\n  const [recentSearches, setRecentSearches] = useState([]);\n  \n  // Store recent searches in local storage\n  useEffect(() => {\n    const storedSearches = localStorage.getItem('recentSearches');\n    if (storedSearches) {\n      try {\n        setRecentSearches(JSON.parse(storedSearches));\n      } catch (err) {\n        console.error(\"Error parsing stored searches:\", err);\n        localStorage.removeItem('recentSearches');\n      }\n    }\n  }, []);\n  \n  // Update recent searches when a new search is performed\n  const addRecentSearch = (search) => {\n    // Don't add empty searches\n    if (!search.query.trim()) return;\n    \n    // Add to recent searches (avoiding duplicates)\n    const updatedSearches = [\n      search,\n      ...recentSearches.filter(s => s.query !== search.query)\n    ].slice(0, 5); // Keep only 5 most recent\n    \n    setRecentSearches(updatedSearches);\n    localStorage.setItem('recentSearches', JSON.stringify(updatedSearches));\n  };\n  \n  const clearRecentSearches = () => {\n    setRecentSearches([]);\n    localStorage.removeItem('recentSearches');\n  };\n  \n  return (\n    <SearchContext.Provider value={{\n      searchOpen,\n      setSearchOpen,\n      lastSearch,\n      setLastSearch,\n      recentSearches,\n      addRecentSearch,\n      clearRecentSearches\n    }}>\n      {children}\n    </SearchContext.Provider>\n  );\n}\n\nexport const useSearch = () => useContext(SearchContext);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-chat-ui",children:"Integration with Chat UI"}),"\n",(0,a.jsx)(n.p,{children:"I integrated the search feature into the main chat interface:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In ChatHeader.jsx\nfunction ChatHeader() {\n  const { currentChat } = useChat();\n  const { searchOpen, setSearchOpen } = useSearch();\n  \n  return (\n    <div className={styles.chatHeader}>\n      <div className={styles.chatInfo}>\n        <h2>{currentChat?.name || 'Chat'}</h2>\n        <div className={styles.chatMeta}>\n          {currentChat?.participantCount || 0} participants\n        </div>\n      </div>\n      \n      <div className={styles.chatActions}>\n        <button\n          className={`${styles.actionButton} ${searchOpen ? styles.active : ''}`}\n          onClick={() => setSearchOpen(!searchOpen)}\n          aria-label=\"Search messages\"\n          title=\"Search messages\"\n        >\n          <SearchIcon />\n        </button>\n        \n        {/* Other action buttons */}\n      </div>\n    </div>\n  );\n}\n\n// In ChatArea.jsx\nfunction ChatArea() {\n  const { searchOpen } = useSearch();\n  \n  return (\n    <div className={styles.chatArea}>\n      <ChatHeader />\n      \n      <div className={styles.chatContent}>\n        {searchOpen ? (\n          <div className={styles.searchOverlay}>\n            <MessageSearch />\n          </div>\n        ) : (\n          <MessageList />\n        )}\n      </div>\n      \n      <MessageInput />\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"search-optimization",children:"Search Optimization"}),"\n",(0,a.jsx)(n.p,{children:"Since Firebase Realtime Database doesn't support full-text search, I had to optimize the search functionality:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// src/utils/searchUtils.js\n// Helper function to preprocess search text\nexport const preprocessSearchText = (text) => {\n  if (!text) return '';\n  return text\n    .toLowerCase()\n    .replace(/[^\\w\\s]/g, '') // Remove special chars\n    .trim();\n};\n\n// For better performance with large message sets\nexport const batchProcessMessages = (messages, searchFunction, batchSize = 50) => {\n  return new Promise((resolve) => {\n    const results = [];\n    let index = 0;\n    \n    function processNextBatch() {\n      const batch = messages.slice(index, index + batchSize);\n      \n      if (batch.length === 0) {\n        resolve(results);\n        return;\n      }\n      \n      // Process this batch\n      const batchResults = batch.filter(searchFunction);\n      results.push(...batchResults);\n      \n      index += batchSize;\n      \n      // Schedule next batch to avoid blocking the UI\n      setTimeout(processNextBatch, 0);\n    }\n    \n    processNextBatch();\n  });\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"technical-challenges",children:"Technical Challenges"}),"\n",(0,a.jsx)(n.h3,{id:"large-message-sets",children:"Large Message Sets"}),"\n",(0,a.jsx)(n.p,{children:"Searching through a large number of messages could cause performance issues:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Client-side Filtering"})," - Since Firebase doesn't support text search, I had to download all messages and filter them client-side, which can be slow for large chats."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Pagination"})," - To address this, I implemented pagination for search results, loading only a limited number of messages at a time."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In MessageSearch.jsx\nconst [currentPage, setCurrentPage] = useState(1);\nconst resultsPerPage = 20;\n\n// Calculate pagination\nconst totalPages = Math.ceil(searchResults.length / resultsPerPage);\nconst paginatedResults = searchResults.slice(\n  (currentPage - 1) * resultsPerPage,\n  currentPage * resultsPerPage\n);\n\n// Pagination controls\nconst handlePageChange = (newPage) => {\n  if (newPage < 1 || newPage > totalPages) return;\n  setCurrentPage(newPage);\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"search-index",children:"Search Index"}),"\n",(0,a.jsx)(n.p,{children:"For faster searches, I experimented with a simple indexing approach:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In ChatContext.jsx\n// When a message is sent, we also update the search index\nconst sendMessage = async (messageData) => {\n  // ... existing code to send message ...\n  \n  // Add to search index\n  if (messageData.type === 'text') {\n    try {\n      const words = messageData.content\n        .toLowerCase()\n        .split(/\\s+/)\n        .filter(word => word.length > 3) // Only index meaningful words\n        .reduce((acc, word) => {\n          acc[word] = true;\n          return acc;\n        }, {});\n      \n      // Store the search index\n      const indexRef = ref(db, `searchIndex/${messageData.chatId}/${messageData.id}`);\n      await set(indexRef, {\n        words,\n        senderId: messageData.senderId,\n        timestamp: messageData.timestamp\n      });\n    } catch (err) {\n      console.error(\"Error updating search index:\", err);\n    }\n  }\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,a.jsx)(n.p,{children:"I have several ideas to enhance the search functionality:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Elasticsearch Integration"})," - For larger deployments, integrating with Elasticsearch would provide much better search capabilities."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Search Suggestions"})," - Add auto-complete and search suggestions based on message content."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Rich Media Search"})," - Implement content-based search for images and files using metadata."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Jump To Context"})," - When clicking a search result, show a few messages before and after for better context."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Export Search Results"})," - Allow users to export search results for record-keeping."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The message search feature has been very well received by users who need to reference past conversations frequently. It's especially useful in work contexts where important information needs to be retrieved quickly."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>i});var t=s(6540);const a={},r=t.createContext(a);function c(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);