"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[6876],{7315:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Features/message-status","title":"Message Status Features","description":"One of the most annoying things in chat apps is when messages seem to disappear or take forever to send. I decided to improve the user experience by implementing a proper message status system with optimistic updates and visual indicators.","source":"@site/docs-source/Features/message-status.md","sourceDirName":"Features","slug":"/Features/message-status","permalink":"/CustomChatApp/docs/Features/message-status","draft":false,"unlisted":false,"editUrl":"https://github.com/Emir2099/CustomChatApp/docs-source/Features/message-status.md","tags":[],"version":"current","lastUpdatedAt":1747596735000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Reply System","permalink":"/CustomChatApp/docs/Features/reply-system"},"next":{"title":"User Blocking System","permalink":"/CustomChatApp/docs/Features/user-blocking"}}');var a=s(4848),i=s(8453);const r={sidebar_position:4},o="Message Status Features",d={},c=[{value:"Optimistic Updates",id:"optimistic-updates",level:2},{value:"Pending Message Indicators",id:"pending-message-indicators",level:2},{value:"CSS Styling for Message States",id:"css-styling-for-message-states",level:2},{value:"Message Queue for Offline Support",id:"message-queue-for-offline-support",level:2},{value:"Message Status Workflow",id:"message-status-workflow",level:2},{value:"Technical Challenges",id:"technical-challenges",level:2},{value:"Race Conditions",id:"race-conditions",level:3},{value:"Connection Status Edge Cases",id:"connection-status-edge-cases",level:3},{value:"Message Deduplication",id:"message-deduplication",level:3},{value:"User Experience Benefits",id:"user-experience-benefits",level:2},{value:"Future Improvements",id:"future-improvements",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"message-status-features",children:"Message Status Features"})}),"\n",(0,a.jsx)(n.p,{children:"One of the most annoying things in chat apps is when messages seem to disappear or take forever to send. I decided to improve the user experience by implementing a proper message status system with optimistic updates and visual indicators."}),"\n",(0,a.jsx)(n.h2,{id:"optimistic-updates",children:"Optimistic Updates"}),"\n",(0,a.jsx)(n.p,{children:"Optimistic UI updates are a technique where we update the UI immediately before waiting for server confirmation. This makes the app feel super responsive. Here's how I implemented it:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In ChatContext.jsx\nconst sendMessage = async (content, replyToId = null) => {\n  if (!currentChat?.id || !user?.uid || !content.trim()) return;\n  \n  // Create a temporary message ID\n  const tempId = `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  \n  // Create the message object\n  const message = {\n    id: tempId,\n    content: content.trim(),\n    sender: user.uid,\n    senderName: user.displayName,\n    senderPhotoURL: user.photoURL,\n    timestamp: Date.now(),\n    readBy: {\n      [user.uid]: Date.now()\n    },\n    replyTo: replyToId,\n    pending: true // Mark as pending initially\n  };\n  \n  // Optimistically add the message to our state\n  setMessages(prev => [...prev, message]);\n  \n  try {\n    // Send to Firebase\n    const messageRef = push(ref(db, `messages/${currentChat.id}`));\n    \n    // Replace the temp ID with the real one from Firebase\n    const realId = messageRef.key;\n    message.id = realId;\n    message.pending = false; // No longer pending\n    \n    await set(messageRef, message);\n    \n    // Update the message in our state to remove pending status\n    setMessages(prev => \n      prev.map(msg => \n        msg.id === tempId ? { ...msg, id: realId, pending: false } : msg\n      )\n    );\n    \n    // Update last message in chat\n    await update(ref(db, `chats/${currentChat.id}`), {\n      lastMessage: {\n        content: content.trim(),\n        sender: user.uid,\n        senderName: user.displayName,\n        timestamp: serverTimestamp()\n      },\n      lastMessageTime: serverTimestamp()\n    });\n    \n    return realId;\n  } catch (error) {\n    console.error('Error sending message:', error);\n    \n    // Update UI to show send failure\n    setMessages(prev => \n      prev.map(msg => \n        msg.id === tempId ? { ...msg, sendFailed: true } : msg\n      )\n    );\n    \n    return null;\n  }\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"pending-message-indicators",children:"Pending Message Indicators"}),"\n",(0,a.jsx)(n.p,{children:"I wanted users to know when their message is still being sent, so I added visual indicators:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In MessageItem.jsx\nfunction MessageItem({ message, isOwnMessage }) {\n  // Determine message status\n  const renderMessageStatus = () => {\n    if (message.pending) {\n      return <span className={styles.pending}>Sending...</span>;\n    }\n    \n    if (message.sendFailed) {\n      return (\n        <span className={styles.failed}>\n          Failed to send\n          <button \n            onClick={() => retrySend(message)} \n            className={styles.retryButton}\n          >\n            Retry\n          </button>\n        </span>\n      );\n    }\n    \n    // Message sent successfully\n    const readByCount = Object.keys(message.readBy || {}).length;\n    if (readByCount > 1) {\n      return <span className={styles.read}>Read</span>;\n    } else {\n      return <span className={styles.sent}>Sent</span>;\n    }\n  };\n  \n  return (\n    <div className={`\n      ${styles.messageItem}\n      ${isOwnMessage ? styles.ownMessage : ''}\n      ${message.pending ? styles.pendingMessage : ''}\n      ${message.sendFailed ? styles.failedMessage : ''}\n    `}>\n      {/* Message content */}\n      <div className={styles.content}>{message.content}</div>\n      \n      {/* Message footer with timestamp and status */}\n      <div className={styles.footer}>\n        <span className={styles.timestamp}>\n          {formatTimestamp(message.timestamp)}\n        </span>\n        \n        {isOwnMessage && renderMessageStatus()}\n      </div>\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"css-styling-for-message-states",children:"CSS Styling for Message States"}),"\n",(0,a.jsx)(n.p,{children:"I added some subtle styling to indicate different message states:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-css",children:"/* MessageItem.module.css */\n.messageItem {\n  /* Base message styling */\n  margin-bottom: 8px;\n  padding: 10px 12px;\n  border-radius: 16px;\n  max-width: 70%;\n  position: relative;\n}\n\n.ownMessage {\n  background-color: #0084ff;\n  color: white;\n  align-self: flex-end;\n  border-bottom-right-radius: 4px;\n}\n\n/* Pending message styling */\n.pendingMessage {\n  opacity: 0.8;\n  animation: pulse 1.5s infinite ease-in-out;\n}\n\n@keyframes pulse {\n  0% { opacity: 0.6; }\n  50% { opacity: 0.8; }\n  100% { opacity: 0.6; }\n}\n\n/* Failed message styling */\n.failedMessage {\n  border: 1px solid #ff4d4f;\n  background-color: rgba(255, 77, 79, 0.1);\n}\n\n/* Status indicators */\n.pending, .sent, .read, .failed {\n  font-size: 11px;\n  margin-left: 4px;\n  display: inline-block;\n}\n\n.pending {\n  color: #a0a0a0;\n}\n\n.sent {\n  color: #a0a0a0;\n}\n\n.read {\n  color: #52c41a;\n}\n\n.failed {\n  color: #ff4d4f;\n  display: flex;\n  align-items: center;\n  gap: 4px;\n}\n\n.retryButton {\n  background: none;\n  border: none;\n  color: #1890ff;\n  text-decoration: underline;\n  cursor: pointer;\n  padding: 0;\n  font-size: 11px;\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"message-queue-for-offline-support",children:"Message Queue for Offline Support"}),"\n",(0,a.jsx)(n.p,{children:"One tricky problem was handling message sending when the user goes offline. I created a queue system to store messages and try sending them when connection is restored:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In ChatContext.jsx\nconst [messageQueue, setMessageQueue] = useState([]);\nconst [isConnected, setIsConnected] = useState(true);\n\n// Monitor connection status\nuseEffect(() => {\n  const connectedRef = ref(db, '.info/connected');\n  const unsubscribe = onValue(connectedRef, (snap) => {\n    const connected = snap.val() === true;\n    setIsConnected(connected);\n    \n    if (connected && messageQueue.length > 0) {\n      processMessageQueue();\n    }\n  });\n  \n  return () => unsubscribe();\n}, [messageQueue]);\n\n// Process queued messages when back online\nconst processMessageQueue = async () => {\n  if (messageQueue.length === 0) return;\n  \n  const queueCopy = [...messageQueue];\n  setMessageQueue([]);\n  \n  for (const queuedMessage of queueCopy) {\n    try {\n      await sendMessage(queuedMessage.content, queuedMessage.replyToId);\n    } catch (error) {\n      console.error('Failed to send queued message:', error);\n      // Add back to queue if still failing\n      setMessageQueue(prev => [...prev, queuedMessage]);\n      break;\n    }\n  }\n};\n\n// Modified send function to handle offline state\nconst sendMessage = async (content, replyToId = null) => {\n  if (!currentChat?.id || !user?.uid || !content.trim()) return;\n  \n  // If offline, add to queue\n  if (!isConnected) {\n    setMessageQueue(prev => [...prev, { content, replyToId }]);\n    \n    // Create an optimistic message marked as queued\n    const tempId = `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    const message = {\n      id: tempId,\n      content: content.trim(),\n      sender: user.uid,\n      senderName: user.displayName,\n      senderPhotoURL: user.photoURL,\n      timestamp: Date.now(),\n      readBy: {\n        [user.uid]: Date.now()\n      },\n      replyTo: replyToId,\n      pending: true,\n      queued: true\n    };\n    \n    setMessages(prev => [...prev, message]);\n    return tempId;\n  }\n  \n  // Normal online flow continues here\n  // ...\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"message-status-workflow",children:"Message Status Workflow"}),"\n",(0,a.jsx)(n.p,{children:"The full message workflow I implemented is:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Composing"})," - User is typing the message"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Sending"})," - Message has been sent but not confirmed by the server (pending)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Sent"})," - Server has confirmed receipt"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Read"})," - Other chat participants have seen the message"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"For each state, I provide appropriate visual feedback to the user."}),"\n",(0,a.jsx)(n.h2,{id:"technical-challenges",children:"Technical Challenges"}),"\n",(0,a.jsx)(n.h3,{id:"race-conditions",children:"Race Conditions"}),"\n",(0,a.jsx)(n.p,{children:"One issue I had to handle was race conditions with optimistic updates. For example, if a user sends multiple messages quickly, the order can get mixed up:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// In ChatContext.jsx - Ensuring message order\nconst sendMessage = async (content, replyToId = null) => {\n  // ...\n  \n  // Use client-side timestamp for optimistic updates\n  const clientTimestamp = Date.now();\n  \n  const message = {\n    // ...\n    timestamp: clientTimestamp,\n    // ...\n  };\n  \n  // Sort messages by timestamp after adding the new one\n  setMessages(prev => [...prev, message].sort((a, b) => a.timestamp - b.timestamp));\n  \n  try {\n    // ...\n    \n    // When updating with the real message, preserve our client timestamp\n    // This keeps the message in the same position in the list\n    await set(messageRef, {\n      ...message,\n      serverTimestamp: serverTimestamp() // Add server timestamp separately\n    });\n    \n    // ...\n  } catch (error) {\n    // ...\n  }\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"connection-status-edge-cases",children:"Connection Status Edge Cases"}),"\n",(0,a.jsx)(n.p,{children:"Another challenge was handling various edge cases with connectivity:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// Handling reconnection edge cases\nuseEffect(() => {\n  let reconnectTimer;\n  \n  const handleOnline = () => {\n    // Clear any reconnect timers\n    if (reconnectTimer) {\n      clearTimeout(reconnectTimer);\n    }\n    \n    // Wait a bit for Firebase to reconnect before processing queue\n    reconnectTimer = setTimeout(() => {\n      if (messageQueue.length > 0) {\n        processMessageQueue();\n      }\n    }, 2000);\n  };\n  \n  const handleOffline = () => {\n    // Update connection status immediately for better UX\n    setIsConnected(false);\n  };\n  \n  // Listen for browser online/offline events as backup\n  window.addEventListener('online', handleOnline);\n  window.addEventListener('offline', handleOffline);\n  \n  return () => {\n    window.removeEventListener('online', handleOnline);\n    window.removeEventListener('offline', handleOffline);\n    if (reconnectTimer) clearTimeout(reconnectTimer);\n  };\n}, [messageQueue]);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"message-deduplication",children:"Message Deduplication"}),"\n",(0,a.jsx)(n.p,{children:"With optimistic updates, you can end up with duplicate messages if you're not careful:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// Prevent duplicate messages - helper function I added to ChatContext\nconst deduplicateMessages = (messages) => {\n  const messageMap = new Map();\n  \n  // Process messages in reverse (newer first)\n  // This ensures we keep the most recent version of each message\n  for (let i = messages.length - 1; i >= 0; i--) {\n    const msg = messages[i];\n    const key = msg.id.startsWith('temp-') ? msg.content + msg.timestamp : msg.id;\n    \n    if (!messageMap.has(key)) {\n      messageMap.set(key, msg);\n    }\n  }\n  \n  // Convert back to array and sort by timestamp\n  return Array.from(messageMap.values())\n    .sort((a, b) => a.timestamp - b.timestamp);\n};\n\n// Use this when merging new messages with existing ones\nsetMessages(prevMessages => {\n  const allMessages = [...prevMessages, ...newMessages];\n  return deduplicateMessages(allMessages);\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"user-experience-benefits",children:"User Experience Benefits"}),"\n",(0,a.jsx)(n.p,{children:"These message status features have dramatically improved the user experience:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Instant Feedback"}),": Users see their messages appear immediately"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Clear Status"}),": Users always know if their message was sent successfully"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Offline Support"}),": Messages don't get lost when connection drops"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Less Frustration"}),": No more wondering if a message was sent or not"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,a.jsx)(n.p,{children:"If I were to enhance this further, I'd add:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Message delivery confirmation (double check marks like WhatsApp)"}),"\n",(0,a.jsx)(n.li,{children:"Per-user read status for group chats"}),"\n",(0,a.jsx)(n.li,{children:"More sophisticated offline persistence with IndexedDB"}),"\n",(0,a.jsx)(n.li,{children:"Background sync using Service Workers"}),"\n",(0,a.jsx)(n.li,{children:"More detailed error messages for different failure types"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>o});var t=s(6540);const a={},i=t.createContext(a);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);