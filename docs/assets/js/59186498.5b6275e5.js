"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2163],{1238:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"Contexts/chat-context","title":"Chat Context","description":"The ChatContext is a central piece of the application that manages all chat-related state and functionality. This document explains how the Chat Context is implemented and how to use it in components.","source":"@site/docs-source/Contexts/chat-context.md","sourceDirName":"Contexts","slug":"/Contexts/chat-context","permalink":"/CustomChatApp/docs/Contexts/chat-context","draft":false,"unlisted":false,"editUrl":"https://github.com/Emir2099/CustomChatApp/docs-source/Contexts/chat-context.md","tags":[],"version":"current","lastUpdatedAt":1747596452000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"AuthContext","permalink":"/CustomChatApp/docs/Contexts/auth-context"},"next":{"title":"Authentication System","permalink":"/CustomChatApp/docs/Features/authentication"}}');var a=s(4848),r=s(8453);const o={sidebar_position:2},i="Chat Context",d={},l=[{value:"Overview",id:"overview",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Key Functions",id:"key-functions",level:2},{value:"Message Management",id:"message-management",level:3},{value:"Send a Text Message",id:"send-a-text-message",level:4},{value:"Send a File Message",id:"send-a-file-message",level:4},{value:"Best Practices",id:"best-practices",level:2},{value:"Customization",id:"customization",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"chat-context",children:"Chat Context"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"ChatContext"})," is a central piece of the application that manages all chat-related state and functionality. This document explains how the Chat Context is implemented and how to use it in components."]}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"The Chat Context provides:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Access to chat conversations and messages"}),"\n",(0,a.jsx)(n.li,{children:"Methods for sending, editing, and deleting messages"}),"\n",(0,a.jsx)(n.li,{children:"User presence and typing indicators"}),"\n",(0,a.jsx)(n.li,{children:"File upload functionality"}),"\n",(0,a.jsx)(n.li,{children:"Voice message recording"}),"\n",(0,a.jsx)(n.li,{children:"Message reactions"}),"\n",(0,a.jsx)(n.li,{children:"User blocking capabilities"}),"\n",(0,a.jsx)(n.li,{children:"Read receipts"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsx)(n.p,{children:"The Chat Context is implemented using React's Context API:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// src/contexts/ChatContext.jsx\nimport { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react';\nimport { \n  ref, \n  onValue, \n  push, \n  set, \n  update, \n  remove,\n  get,\n  query,\n  orderByChild,\n  limitToLast,\n  serverTimestamp \n} from 'firebase/database';\nimport { \n  ref as storageRef, \n  uploadBytesResumable, \n  getDownloadURL,\n  deleteObject \n} from 'firebase/storage';\nimport { db, storage } from '../config/firebase';\nimport { useAuth } from './AuthContext';\nimport { v4 as uuidv4 } from 'uuid';\n\n// Create the context\nconst ChatContext = createContext();\n\n// Constants\nconst FILE_SIZE_LIMIT = 10 * 1024 * 1024; // 10MB\nconst ALLOWED_FILE_TYPES = [\n  'image/jpeg',\n  'image/png',\n  'image/gif',\n  'application/pdf',\n  'text/plain',\n  // ... other allowed types\n];\n\nexport function ChatProvider({ children }) {\n  // State variables\n  const [chats, setChats] = useState([]);\n  const [currentChat, setCurrentChat] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [allUsers, setAllUsers] = useState({});\n  const [typingUsers, setTypingUsers] = useState({});\n  const [fileUploads, setFileUploads] = useState({});\n  const [hasMoreMessages, setHasMoreMessages] = useState(true);\n  \n  // Get the current user from AuthContext\n  const { user } = useAuth();\n  \n  // Other refs and state\n  // ...\n\n  // Load user data\n  useEffect(() => {\n    if (!user?.uid) return;\n    \n    const usersRef = ref(db, 'users');\n    const unsubscribe = onValue(usersRef, (snapshot) => {\n      if (snapshot.exists()) {\n        setAllUsers(snapshot.val());\n      }\n    });\n    \n    return () => unsubscribe();\n  }, [user]);\n\n  // Load user's chats\n  useEffect(() => {\n    if (!user?.uid) return;\n    \n    setLoading(true);\n    const userChatsRef = ref(db, `userChats/${user.uid}`);\n    \n    const unsubscribe = onValue(userChatsRef, async (snapshot) => {\n      try {\n        if (!snapshot.exists()) {\n          setChats([]);\n          setLoading(false);\n          return;\n        }\n\n        const userChatsData = snapshot.val();\n        const chatIds = Object.keys(userChatsData);\n        \n        // Get details for each chat\n        const chatsData = await Promise.all(\n          chatIds.map(async (chatId) => {\n            const chatRef = ref(db, `chats/${chatId}`);\n            const chatSnapshot = await get(chatRef);\n            \n            if (!chatSnapshot.exists()) return null;\n            \n            const chatData = chatSnapshot.val();\n            return {\n              id: chatId,\n              ...chatData,\n              ...userChatsData[chatId]\n            };\n          })\n        );\n        \n        // Filter out null values and sort by last message time\n        const validChats = chatsData\n          .filter(chat => chat !== null)\n          .sort((a, b) => b.lastMessageTime - a.lastMessageTime);\n        \n        setChats(validChats);\n      } catch (err) {\n        console.error('Error loading chats:', err);\n        setError('Failed to load chats');\n      } finally {\n        setLoading(false);\n      }\n    });\n    \n    return () => unsubscribe();\n  }, [user]);\n\n  // Load messages for current chat\n  useEffect(() => {\n    if (!currentChat?.id) {\n      setMessages([]);\n      return;\n    }\n    \n    setLoading(true);\n    const messagesRef = ref(db, `messages/${currentChat.id}`);\n    const messagesQuery = query(\n      messagesRef,\n      orderByChild('timestamp'),\n      limitToLast(20)\n    );\n    \n    const unsubscribe = onValue(messagesQuery, (snapshot) => {\n      try {\n        if (!snapshot.exists()) {\n          setMessages([]);\n          setHasMoreMessages(false);\n          setLoading(false);\n          return;\n        }\n        \n        const messagesObj = snapshot.val();\n        const messagesList = Object.keys(messagesObj).map(key => ({\n          id: key,\n          ...messagesObj[key]\n        }));\n        \n        // Sort messages by timestamp\n        messagesList.sort((a, b) => a.timestamp - b.timestamp);\n        \n        setMessages(messagesList);\n        setHasMoreMessages(true);\n      } catch (err) {\n        console.error('Error loading messages:', err);\n        setError('Failed to load messages');\n      } finally {\n        setLoading(false);\n      }\n    });\n    \n    // Mark chat as read when opened\n    if (user?.uid) {\n      markChatAsRead(currentChat.id);\n    }\n    \n    return () => unsubscribe();\n  }, [currentChat?.id, user?.uid]);\n\n  // Load more messages (pagination)\n  const loadMoreMessages = useCallback(async (count = 20) => {\n    if (!currentChat?.id || !messages.length || !hasMoreMessages) {\n      return false;\n    }\n    \n    try {\n      // Get the oldest message timestamp\n      const oldestMessage = messages[0];\n      const oldestTimestamp = oldestMessage.timestamp;\n      \n      // Query messages before the oldest one\n      const messagesRef = ref(db, `messages/${currentChat.id}`);\n      const olderMessagesQuery = query(\n        messagesRef,\n        orderByChild('timestamp'),\n        /* endAt(oldestTimestamp - 1), */\n        limitToLast(count)\n      );\n      \n      const snapshot = await get(olderMessagesQuery);\n      \n      if (!snapshot.exists()) {\n        setHasMoreMessages(false);\n        return false;\n      }\n      \n      const messagesObj = snapshot.val();\n      const messagesList = Object.keys(messagesObj)\n        .map(key => ({\n          id: key,\n          ...messagesObj[key]\n        }))\n        .filter(msg => msg.timestamp < oldestTimestamp); // Filter out messages we already have\n      \n      if (messagesList.length === 0) {\n        setHasMoreMessages(false);\n        return false;\n      }\n      \n      // Sort messages by timestamp\n      messagesList.sort((a, b) => a.timestamp - b.timestamp);\n      \n      // Add older messages to the beginning of the list\n      setMessages(prevMessages => [...messagesList, ...prevMessages]);\n      \n      return messagesList.length >= count; // Return true if there might be more messages\n    } catch (err) {\n      console.error('Error loading more messages:', err);\n      setError('Failed to load more messages');\n      return false;\n    }\n  }, [currentChat?.id, messages, hasMoreMessages]);\n\n  // Send a text message\n  const sendMessage = useCallback(async (content, replyToId = null) => {\n    if (!user?.uid || !currentChat?.id || !content.trim()) {\n      return null;\n    }\n    \n    try {\n      const messagesRef = ref(db, `messages/${currentChat.id}`);\n      const newMessageRef = push(messagesRef);\n      const messageId = newMessageRef.key;\n      \n      const messageData = {\n        content: content.trim(),\n        sender: user.uid,\n        timestamp: Date.now(),\n        replyTo: replyToId,\n        readBy: {\n          [user.uid]: Date.now()\n        }\n      };\n      \n      await set(newMessageRef, messageData);\n      \n      // Update chat's last message\n      const chatRef = ref(db, `chats/${currentChat.id}`);\n      await update(chatRef, {\n        lastMessage: {\n          content: content.trim().substring(0, 50) + (content.length > 50 ? '...' : ''),\n          sender: user.uid,\n          timestamp: messageData.timestamp\n        },\n        lastMessageTime: messageData.timestamp\n      });\n      \n      // Update unread counts for other participants\n      if (currentChat.type === 'private') {\n        const participants = Object.keys(currentChat.participants || {});\n        const otherUserId = participants.find(id => id !== user.uid);\n        \n        if (otherUserId) {\n          const userChatRef = ref(db, `userChats/${otherUserId}/${currentChat.id}`);\n          const snapshot = await get(userChatRef);\n          const userData = snapshot.val() || {};\n          \n          await update(userChatRef, {\n            unreadCount: (userData.unreadCount || 0) + 1\n          });\n        }\n      } else if (currentChat.type === 'group') {\n        const members = Object.keys(currentChat.members || {});\n        \n        // Update unread count for all members except the sender\n        for (const memberId of members) {\n          if (memberId !== user.uid) {\n            const userChatRef = ref(db, `userChats/${memberId}/${currentChat.id}`);\n            const snapshot = await get(userChatRef);\n            const userData = snapshot.val() || {};\n            \n            await update(userChatRef, {\n              unreadCount: (userData.unreadCount || 0) + 1\n            });\n          }\n        }\n      }\n      \n      return messageId;\n    } catch (err) {\n      console.error('Error sending message:', err);\n      setError('Failed to send message');\n      return null;\n    }\n  }, [user, currentChat]);\n\n  // Send a file message\n  const sendFileMessage = useCallback(async (file, progressCallback, replyToId = null) => {\n    if (!user?.uid || !currentChat?.id || !file) {\n      return null;\n    }\n    \n    try {\n      // Create a placeholder for the file message\n      const messagesRef = ref(db, `messages/${currentChat.id}`);\n      const newMessageRef = push(messagesRef);\n      const messageId = newMessageRef.key;\n      \n      // Generate a unique file name\n      const fileExtension = file.name.split('.').pop();\n      const fileName = `${uuidv4()}.${fileExtension}`;\n      const filePath = `chat/${currentChat.id}/${fileName}`;\n      \n      // Create file upload entry\n      const uploadId = uuidv4();\n      setFileUploads(prev => ({\n        ...prev,\n        [uploadId]: {\n          id: uploadId,\n          fileName: file.name,\n          progress: 0,\n          status: 'uploading'\n        }\n      }));\n      \n      // Upload file to storage\n      const fileRef = storageRef(storage, filePath);\n      const uploadTask = uploadBytesResumable(fileRef, file);\n      \n      // Monitor upload progress\n      uploadTask.on(\n        'state_changed',\n        (snapshot) => {\n          const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\n          \n          setFileUploads(prev => ({\n            ...prev,\n            [uploadId]: {\n              ...prev[uploadId],\n              progress\n            }\n          }));\n          \n          if (progressCallback) {\n            progressCallback(progress);\n          }\n        },\n        (error) => {\n          console.error('Error uploading file:', error);\n          setFileUploads(prev => ({\n            ...prev,\n            [uploadId]: {\n              ...prev[uploadId],\n              status: 'error',\n              error: error.message\n            }\n          }));\n        },\n        async () => {\n          try {\n            // Get download URL\n            const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);\n            \n            // Create message with file data\n            const messageData = {\n              type: 'file',\n              fileName: file.name,\n              fileSize: file.size,\n              fileType: file.type,\n              fileURL: downloadURL,\n              sender: user.uid,\n              timestamp: Date.now(),\n              replyTo: replyToId,\n              readBy: {\n                [user.uid]: Date.now()\n              }\n            };\n            \n            // For image files, add dimensions and thumbnail\n            if (file.type.startsWith('image/')) {\n              messageData.isImage = true;\n              \n              // We could add image dimensions here if needed\n              // messageData.imageDimensions = { width, height };\n            }\n            \n            // Save message to database\n            await set(newMessageRef, messageData);\n            \n            // Update chat's last message\n            const chatRef = ref(db, `chats/${currentChat.id}`);\n            await update(chatRef, {\n              lastMessage: {\n                content: `Sent a file: ${file.name}`,\n                sender: user.uid,\n                timestamp: messageData.timestamp,\n                type: 'file'\n              },\n              lastMessageTime: messageData.timestamp\n            });\n            \n            // Update file upload status\n            setFileUploads(prev => ({\n              ...prev,\n              [uploadId]: {\n                ...prev[uploadId],\n                status: 'complete',\n                progress: 100\n              }\n            }));\n            \n            return messageId;\n          } catch (err) {\n            console.error('Error completing file upload:', err);\n            setFileUploads(prev => ({\n              ...prev,\n              [uploadId]: {\n                ...prev[uploadId],\n                status: 'error',\n                error: err.message\n              }\n            }));\n            return null;\n          }\n        }\n      );\n      \n      return messageId;\n    } catch (err) {\n      console.error('Error sending file message:', err);\n      setError('Failed to send file');\n      return null;\n    }\n  }, [user, currentChat]);\n\n  // Send a voice message\n  const sendVoiceMessage = useCallback(async (audioBlob, duration, replyToId = null) => {\n    if (!user?.uid || !currentChat?.id || !audioBlob) {\n      return null;\n    }\n    \n    try {\n      // Create a placeholder for the voice message\n      const messagesRef = ref(db, `messages/${currentChat.id}`);\n      const newMessageRef = push(messagesRef);\n      const messageId = newMessageRef.key;\n      \n      // Generate a unique file name\n      const fileName = `voice_${uuidv4()}.mp3`;\n      const filePath = `chat/${currentChat.id}/${fileName}`;\n      \n      // Create file upload entry\n      const uploadId = uuidv4();\n      setFileUploads(prev => ({\n        ...prev,\n        [uploadId]: {\n          id: uploadId,\n          fileName,\n          progress: 0,\n          status: 'uploading'\n        }\n      }));\n      \n      // Upload audio to storage\n      const fileRef = storageRef(storage, filePath);\n      const uploadTask = uploadBytesResumable(fileRef, audioBlob);\n      \n      // Monitor upload progress\n      uploadTask.on(\n        'state_changed',\n        (snapshot) => {\n          const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\n          \n          setFileUploads(prev => ({\n            ...prev,\n            [uploadId]: {\n              ...prev[uploadId],\n              progress\n            }\n          }));\n        },\n        (error) => {\n          console.error('Error uploading voice message:', error);\n          setFileUploads(prev => ({\n            ...prev,\n            [uploadId]: {\n              ...prev[uploadId],\n              status: 'error',\n              error: error.message\n            }\n          }));\n        },\n        async () => {\n          try {\n            // Get download URL\n            const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);\n            \n            // Create message with voice data\n            const messageData = {\n              type: 'voice',\n              fileURL: downloadURL,\n              duration: duration || 0,\n              sender: user.uid,\n              timestamp: Date.now(),\n              replyTo: replyToId,\n              readBy: {\n                [user.uid]: Date.now()\n              }\n            };\n            \n            // Save message to database\n            await set(newMessageRef, messageData);\n            \n            // Update chat's last message\n            const chatRef = ref(db, `chats/${currentChat.id}`);\n            await update(chatRef, {\n              lastMessage: {\n                content: 'Sent a voice message',\n                sender: user.uid,\n                timestamp: messageData.timestamp,\n                type: 'voice'\n              },\n              lastMessageTime: messageData.timestamp\n            });\n            \n            // Update file upload status\n            setFileUploads(prev => ({\n              ...prev,\n              [uploadId]: {\n                ...prev[uploadId],\n                status: 'complete',\n                progress: 100\n              }\n            }));\n            \n            return messageId;\n          } catch (err) {\n            console.error('Error completing voice message upload:', err);\n            setFileUploads(prev => ({\n              ...prev,\n              [uploadId]: {\n                ...prev[uploadId],\n                status: 'error',\n                error: err.message\n              }\n            }));\n            return null;\n          }\n        }\n      );\n      \n      return messageId;\n    } catch (err) {\n      console.error('Error sending voice message:', err);\n      setError('Failed to send voice message');\n      return null;\n    }\n  }, [user, currentChat]);\n\n  // Update typing status\n  const setTypingStatus = useCallback((isTyping) => {\n    if (!user?.uid || !currentChat?.id) {\n      return;\n    }\n    \n    const typingRef = ref(db, `typing/${currentChat.id}/${user.uid}`);\n    \n    update(typingRef, {\n      isTyping,\n      timestamp: Date.now()\n    }).catch(err => {\n      console.error('Error updating typing status:', err);\n    });\n  }, [user, currentChat]);\n\n  // Listen for typing indicators\n  useEffect(() => {\n    if (!currentChat?.id) {\n      setTypingUsers({});\n      return;\n    }\n    \n    const typingRef = ref(db, `typing/${currentChat.id}`);\n    \n    const unsubscribe = onValue(typingRef, (snapshot) => {\n      if (!snapshot.exists()) {\n        setTypingUsers({});\n        return;\n      }\n      \n      const typing = snapshot.val();\n      setTypingUsers(typing);\n    });\n    \n    return () => unsubscribe();\n  }, [currentChat?.id]);\n\n  // Edit a message\n  const editMessage = useCallback(async (messageId, newContent) => {\n    if (!user?.uid || !currentChat?.id || !messageId || !newContent.trim()) {\n      return false;\n    }\n    \n    try {\n      const messageRef = ref(db, `messages/${currentChat.id}/${messageId}`);\n      const snapshot = await get(messageRef);\n      \n      if (!snapshot.exists()) {\n        throw new Error('Message not found');\n      }\n      \n      const message = snapshot.val();\n      \n      // Check if current user is the sender\n      if (message.sender !== user.uid) {\n        throw new Error('You can only edit your own messages');\n      }\n      \n      // Update message content\n      await update(messageRef, {\n        content: newContent.trim(),\n        edited: true,\n        editedAt: Date.now()\n      });\n      \n      // If this was the last message, update the chat preview\n      const chatRef = ref(db, `chats/${currentChat.id}`);\n      const chatSnapshot = await get(chatRef);\n      \n      if (chatSnapshot.exists()) {\n        const chat = chatSnapshot.val();\n        \n        if (chat.lastMessage && chat.lastMessage.timestamp === message.timestamp) {\n          await update(chatRef, {\n            lastMessage: {\n              ...chat.lastMessage,\n              content: newContent.trim().substring(0, 50) + (newContent.length > 50 ? '...' : '')\n            }\n          });\n        }\n      }\n      \n      return true;\n    } catch (err) {\n      console.error('Error editing message:', err);\n      setError(err.message || 'Failed to edit message');\n      return false;\n    }\n  }, [user, currentChat]);\n\n  // Delete a message\n  const deleteMessage = useCallback(async (messageId) => {\n    if (!user?.uid || !currentChat?.id || !messageId) {\n      return false;\n    }\n    \n    try {\n      const messageRef = ref(db, `messages/${currentChat.id}/${messageId}`);\n      const snapshot = await get(messageRef);\n      \n      if (!snapshot.exists()) {\n        throw new Error('Message not found');\n      }\n      \n      const message = snapshot.val();\n      \n      // Check if current user is the sender\n      if (message.sender !== user.uid) {\n        // Also allow admins to delete messages in groups\n        const isAdmin = currentChat.type === 'group' && \n          currentChat.members && \n          currentChat.members[user.uid] && \n          currentChat.members[user.uid].role === 'admin';\n        \n        if (!isAdmin) {\n          throw new Error('You can only delete your own messages');\n        }\n      }\n      \n      // For file messages, delete the file from storage\n      if (message.type === 'file' || message.type === 'voice') {\n        const fileURL = message.fileURL;\n        if (fileURL) {\n          try {\n            // Extract the file path from the URL\n            const url = new URL(fileURL);\n            const path = decodeURIComponent(url.pathname.split('/o/')[1].split('?')[0]);\n            const fileRef = storageRef(storage, path);\n            \n            await deleteObject(fileRef);\n          } catch (fileErr) {\n            console.error('Error deleting file:', fileErr);\n            // Continue with message deletion even if file deletion fails\n          }\n        }\n      }\n      \n      // Soft delete the message by updating it\n      await update(messageRef, {\n        deleted: true,\n        content: message.type === 'file' || message.type === 'voice' \n          ? undefined \n          : 'This message has been deleted',\n        fileURL: undefined,\n        fileName: undefined,\n        fileSize: undefined,\n        fileThumbnail: undefined\n      });\n      \n      // If this was the last message, update the chat preview\n      const chatRef = ref(db, `chats/${currentChat.id}`);\n      const chatSnapshot = await get(chatRef);\n      \n      if (chatSnapshot.exists()) {\n        const chat = chatSnapshot.val();\n        \n        if (chat.lastMessage && chat.lastMessage.timestamp === message.timestamp) {\n          await update(chatRef, {\n            lastMessage: {\n              content: 'This message has been deleted',\n              sender: message.sender,\n              timestamp: message.timestamp,\n              type: 'deleted'\n            }\n          });\n        }\n      }\n      \n      return true;\n    } catch (err) {\n      console.error('Error deleting message:', err);\n      setError(err.message || 'Failed to delete message');\n      return false;\n    }\n  }, [user, currentChat]);\n\n  // Mark a chat as read\n  const markChatAsRead = useCallback(async (chatId) => {\n    if (!user?.uid || !chatId) {\n      return;\n    }\n    \n    try {\n      // Update user chat data\n      const userChatRef = ref(db, `userChats/${user.uid}/${chatId}`);\n      await update(userChatRef, {\n        unreadCount: 0,\n        lastReadTime: Date.now()\n      });\n      \n      // Mark all messages as read by this user\n      const messagesRef = ref(db, `messages/${chatId}`);\n      const snapshot = await get(messagesRef);\n      \n      if (snapshot.exists()) {\n        const messages = snapshot.val();\n        const updates = {};\n        \n        Object.keys(messages).forEach(messageId => {\n          const message = messages[messageId];\n          \n          if (message.sender !== user.uid) {\n            updates[`messages/${chatId}/${messageId}/readBy/${user.uid}`] = Date.now();\n          }\n        });\n        \n        if (Object.keys(updates).length > 0) {\n          await update(ref(db), updates);\n        }\n      }\n    } catch (err) {\n      console.error('Error marking chat as read:', err);\n    }\n  }, [user]);\n\n  // Check if current user is admin in group chat\n  const isCurrentUserAdmin = useCallback(() => {\n    if (!user?.uid || !currentChat?.id || currentChat.type !== 'group') {\n      return false;\n    }\n    \n    return currentChat.members && \n      currentChat.members[user.uid] && \n      currentChat.members[user.uid].role === 'admin';\n  }, [user, currentChat]);\n\n  // Function to block a user\n  const blockUser = useCallback(async (userIdToBlock) => {\n    if (!user?.uid || !userIdToBlock) return;\n\n    try {\n      // Add the user to the blocked list\n      const updates = {};\n      updates[`users/${user.uid}/blockedUsers/${userIdToBlock}`] = true;\n      await update(ref(db), updates);\n      \n      // Update local state\n      console.log(`User ${userIdToBlock} has been blocked`);\n      \n      return true;\n    } catch (error) {\n      console.error('Error blocking user:', error);\n      throw error;\n    }\n  }, [user]);\n\n  // Function to unblock a user\n  const unblockUser = useCallback(async (userIdToUnblock) => {\n    if (!user?.uid || !userIdToUnblock) return;\n\n    try {\n      // Remove the user from the blocked list\n      const updates = {};\n      updates[`users/${user.uid}/blockedUsers/${userIdToUnblock}`] = null;\n      await update(ref(db), updates);\n      \n      // Update local state\n      console.log(`User ${userIdToUnblock} has been unblocked`);\n      \n      return true;\n    } catch (error) {\n      console.error('Error unblocking user:', error);\n      throw error;\n    }\n  }, [user]);\n\n  // Function to check if a user is blocked\n  const isUserBlocked = useCallback((userId) => {\n    if (!user?.uid || !userId || !allUsers?.[user.uid]?.blockedUsers) return false;\n    \n    // Check if userId is in current user's blocked list\n    return !!allUsers[user.uid]?.blockedUsers?.[userId];\n  }, [user, allUsers]);\n\n  // Create the context value\n  const contextValue = {\n    chats,\n    currentChat,\n    setCurrentChat,\n    messages,\n    sendMessage,\n    sendFileMessage,\n    sendVoiceMessage,\n    loading,\n    error,\n    allUsers,\n    fileUploads,\n    typingUsers,\n    setTypingStatus,\n    loadMoreMessages,\n    hasMoreMessages,\n    editMessage,\n    deleteMessage,\n    markChatAsRead,\n    isCurrentUserAdmin,\n    blockUser,\n    unblockUser,\n    isUserBlocked,\n    FILE_SIZE_LIMIT,\n    ALLOWED_FILE_TYPES\n  };\n\n  return (\n    <ChatContext.Provider value={contextValue}>\n      {children}\n    </ChatContext.Provider>\n  );\n}\n\n// Custom hook to use the chat context\nexport function useChat() {\n  return useContext(ChatContext);\n}\n\n## Using the Chat Context\n\nComponents can access the Chat Context through the `useChat` hook:\n\n```jsx\nimport { useChat } from '../../contexts/ChatContext';\n\nfunction ChatComponent() {\n  const { \n    currentChat, \n    messages, \n    sendMessage,\n    loading \n  } = useChat();\n  \n  // Component logic using chat functionality\n  // ...\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"key-functions",children:"Key Functions"}),"\n",(0,a.jsx)(n.h3,{id:"message-management",children:"Message Management"}),"\n",(0,a.jsx)(n.h4,{id:"send-a-text-message",children:"Send a Text Message"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// Send a new text message\nconst { sendMessage } = useChat();\n\nconst handleSend = (e) => {\n  e.preventDefault();\n  if (!newMessage.trim()) return;\n  \n  sendMessage(newMessage);\n  setNewMessage('');\n};\n"})}),"\n",(0,a.jsx)(n.h4,{id:"send-a-file-message",children:"Send a File Message"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// Send a file message\nconst { sendFileMessage } = useChat();\n\nconst handleFileUpload = async (e) => {\n  const file = e.target.files[0];\n  if (!file) return;\n  \n  const onProgress = (progress) => {\n    console.log(`Upload progress: ${progress}%`);\n  };\n  \n  await sendFileMessage(file, onProgress);\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.p,{children:"When using the Chat Context, follow these best practices:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cleanup subscriptions"}),": Be sure to clean up any additional subscriptions or timers in useEffect cleanup functions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimistic updates"}),": For better UX, update the UI optimistically before waiting for Firebase confirmations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Debounce typing updates"}),": Debounce typing indicator updates to reduce database writes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Error boundaries"}),": Wrap chat components in error boundaries to gracefully handle errors"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Loading states"}),": Show appropriate loading UI while data is being fetched or sent"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"customization",children:"Customization"}),"\n",(0,a.jsx)(n.p,{children:"The Chat Context can be customized and extended:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Add new message types"}),": Extend the message sending functions to support new types"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Modify storage paths"}),": Change where files are stored in Firebase Storage"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Add caching"}),": Implement local caching for faster loading and offline support"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Add analytics"}),": Track message sending and reading for analytics"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Enhance security"}),": Add additional checks and validations for message operations"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>i});var t=s(6540);const a={},r=t.createContext(a);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);