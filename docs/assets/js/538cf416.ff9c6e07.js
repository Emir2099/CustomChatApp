"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[9159],{4817:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"Contexts/auth-context","title":"AuthContext","description":"The AuthContext is the foundation of the authentication system in this chat application. It manages user authentication state, login/logout functionality, and user profile updates.","source":"@site/docs-source/Contexts/auth-context.md","sourceDirName":"Contexts","slug":"/Contexts/auth-context","permalink":"/CustomChatApp/docs/Contexts/auth-context","draft":false,"unlisted":false,"editUrl":"https://github.com/Emir2099/CustomChatApp/docs-source/Contexts/auth-context.md","tags":[],"version":"current","lastUpdatedAt":1747596735000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Common Components","permalink":"/CustomChatApp/docs/Components/common-components"},"next":{"title":"Chat Context","permalink":"/CustomChatApp/docs/Contexts/chat-context"}}');var r=t(4848),a=t(8453);const i={sidebar_position:2},o="AuthContext",l={},u=[{value:"Implementation Overview",id:"implementation-overview",level:2},{value:"Core Authentication Functions",id:"core-authentication-functions",level:2},{value:"User Registration",id:"user-registration",level:3},{value:"User Login",id:"user-login",level:3},{value:"User Logout",id:"user-logout",level:3},{value:"Password Reset",id:"password-reset",level:3},{value:"Profile Updates",id:"profile-updates",level:3},{value:"Presence System",id:"presence-system",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Usage Example",id:"usage-example",level:2},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Challenges and Solutions",id:"challenges-and-solutions",level:2},{value:"Challenge 1: User Presence",id:"challenge-1-user-presence",level:3},{value:"Challenge 2: Auth State Persistence",id:"challenge-2-auth-state-persistence",level:3},{value:"Challenge 3: Race Conditions",id:"challenge-3-race-conditions",level:3},{value:"Testing",id:"testing",level:2},{value:"Future Improvements",id:"future-improvements",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"authcontext",children:"AuthContext"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"AuthContext"})," is the foundation of the authentication system in this chat application. It manages user authentication state, login/logout functionality, and user profile updates."]}),"\n",(0,r.jsx)(n.h2,{id:"implementation-overview",children:"Implementation Overview"}),"\n",(0,r.jsx)(n.p,{children:"I built the AuthContext using React's Context API combined with Firebase Authentication. Here's how I structured it:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// src/contexts/AuthContext.jsx\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { \n  auth, \n  db, \n  googleProvider \n} from '../config/firebase';\nimport { \n  createUserWithEmailAndPassword, \n  signInWithEmailAndPassword, \n  signOut, \n  onAuthStateChanged, \n  updateProfile,\n  sendPasswordResetEmail,\n  signInWithPopup\n} from 'firebase/auth';\nimport { ref, set, update, onValue, serverTimestamp } from 'firebase/database';\n\n// Create the context\nconst AuthContext = createContext();\n\n// Custom hook to use the auth context\nexport function useAuth() {\n  return useContext(AuthContext);\n}\n\n// Provider component\nexport function AuthProvider({ children }) {\n  // State\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState('');\n  \n  // Authentication functions\n  // ... (detailed below)\n  \n  // Effect to handle auth state changes\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {\n      setUser(currentUser);\n      setLoading(false);\n      \n      // Update online status in database\n      if (currentUser) {\n        const userStatusRef = ref(db, `users/${currentUser.uid}`);\n        update(userStatusRef, {\n          isOnline: true,\n          lastSeen: serverTimestamp()\n        });\n        \n        // Set up presence system\n        setupPresence(currentUser.uid);\n      }\n    });\n    \n    return () => unsubscribe();\n  }, []);\n  \n  // Context value\n  const value = {\n    user,\n    loading,\n    error,\n    signup,\n    login,\n    logout,\n    resetPassword,\n    updateUserProfile,\n    signInWithGoogle\n  };\n  \n  return (\n    <AuthContext.Provider value={value}>\n      {!loading && children}\n    </AuthContext.Provider>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"core-authentication-functions",children:"Core Authentication Functions"}),"\n",(0,r.jsx)(n.h3,{id:"user-registration",children:"User Registration"}),"\n",(0,r.jsx)(n.p,{children:"I implemented user registration with email/password and automatic profile creation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const signup = async (email, password, displayName) => {\n  try {\n    setError('');\n    // Create the user in Firebase Auth\n    const userCredential = await createUserWithEmailAndPassword(auth, email, password);\n    \n    // Update the user's profile with display name\n    await updateProfile(userCredential.user, { displayName });\n    \n    // Create user document in the database\n    const userRef = ref(db, `users/${userCredential.user.uid}`);\n    await set(userRef, {\n      displayName,\n      email,\n      photoURL: null,\n      createdAt: serverTimestamp(),\n      lastSeen: serverTimestamp(),\n      isOnline: true\n    });\n    \n    return userCredential.user;\n  } catch (err) {\n    setError(formatAuthError(err.code));\n    throw err;\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"user-login",children:"User Login"}),"\n",(0,r.jsx)(n.p,{children:"I created two login methods - email/password and Google authentication:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// Email/password login\nconst login = async (email, password) => {\n  try {\n    setError('');\n    const userCredential = await signInWithEmailAndPassword(auth, email, password);\n    \n    // Update online status\n    const userRef = ref(db, `users/${userCredential.user.uid}`);\n    await update(userRef, {\n      isOnline: true,\n      lastSeen: serverTimestamp()\n    });\n    \n    return userCredential.user;\n  } catch (err) {\n    setError(formatAuthError(err.code));\n    throw err;\n  }\n};\n\n// Google login\nconst signInWithGoogle = async () => {\n  try {\n    setError('');\n    const result = await signInWithPopup(auth, googleProvider);\n    \n    // Check if this is a new user\n    const isNewUser = result._tokenResponse.isNewUser;\n    \n    // If new user, create profile in database\n    if (isNewUser) {\n      const userRef = ref(db, `users/${result.user.uid}`);\n      await set(userRef, {\n        displayName: result.user.displayName,\n        email: result.user.email,\n        photoURL: result.user.photoURL,\n        createdAt: serverTimestamp(),\n        lastSeen: serverTimestamp(),\n        isOnline: true\n      });\n    } else {\n      // Update existing user's online status\n      const userRef = ref(db, `users/${result.user.uid}`);\n      await update(userRef, {\n        isOnline: true,\n        lastSeen: serverTimestamp(),\n        // Update photo URL in case it changed on Google's side\n        photoURL: result.user.photoURL\n      });\n    }\n    \n    return result.user;\n  } catch (err) {\n    setError(formatAuthError(err.code));\n    throw err;\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"user-logout",children:"User Logout"}),"\n",(0,r.jsx)(n.p,{children:"I made sure to update the user's online status before signing out:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const logout = async () => {\n  try {\n    // Update online status before signing out\n    if (user) {\n      const userRef = ref(db, `users/${user.uid}`);\n      await update(userRef, {\n        isOnline: false,\n        lastSeen: serverTimestamp()\n      });\n    }\n    \n    await signOut(auth);\n  } catch (err) {\n    setError(formatAuthError(err.code));\n    throw err;\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"password-reset",children:"Password Reset"}),"\n",(0,r.jsx)(n.p,{children:"I implemented a password reset function:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const resetPassword = async (email) => {\n  try {\n    setError('');\n    await sendPasswordResetEmail(auth, email);\n  } catch (err) {\n    setError(formatAuthError(err.code));\n    throw err;\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"profile-updates",children:"Profile Updates"}),"\n",(0,r.jsx)(n.p,{children:"Users can update their profile information:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const updateUserProfile = async (data) => {\n  try {\n    if (!user) throw new Error('No user logged in');\n    \n    const updates = {};\n    \n    // Update display name if provided\n    if (data.displayName) {\n      await updateProfile(user, { displayName: data.displayName });\n      updates.displayName = data.displayName;\n    }\n    \n    // Update photo URL if provided\n    if (data.photoURL) {\n      await updateProfile(user, { photoURL: data.photoURL });\n      updates.photoURL = data.photoURL;\n    }\n    \n    // Update additional profile fields in database\n    if (data.bio) updates.bio = data.bio;\n    \n    // Only update if we have changes\n    if (Object.keys(updates).length > 0) {\n      const userRef = ref(db, `users/${user.uid}`);\n      await update(userRef, {\n        ...updates,\n        updatedAt: serverTimestamp()\n      });\n    }\n    \n    return true;\n  } catch (err) {\n    setError(err.message);\n    throw err;\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h2,{id:"presence-system",children:"Presence System"}),"\n",(0,r.jsx)(n.p,{children:"One of the more complex parts was implementing a reliable presence system:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const setupPresence = (userId) => {\n  // Firebase presence system\n  const userStatusRef = ref(db, `users/${userId}`);\n  \n  // Create a reference to the special '.info/connected' path\n  const connectedRef = ref(db, '.info/connected');\n  \n  // When the client's connection state changes\n  onValue(connectedRef, (snapshot) => {\n    if (snapshot.val() === false) {\n      // We're not connected (or we've lost our connection)\n      return;\n    }\n    \n    // We're connected (or reconnected)\n    update(userStatusRef, {\n      isOnline: true,\n      lastSeen: serverTimestamp()\n    });\n    \n    // When we disconnect, update the last time we were seen online\n    onDisconnect(userStatusRef).update({\n      isOnline: false,\n      lastSeen: serverTimestamp()\n    });\n  });\n  \n  // Clean up when component unmounts\n  return () => {\n    // Update status to offline\n    update(userStatusRef, {\n      isOnline: false,\n      lastSeen: serverTimestamp()\n    });\n  };\n};\n"})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.p,{children:"I created a helper function to format Firebase auth errors into user-friendly messages:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const formatAuthError = (errorCode) => {\n  switch (errorCode) {\n    case 'auth/user-not-found':\n      return 'No account found with this email address';\n    case 'auth/wrong-password':\n      return 'Incorrect password';\n    case 'auth/email-already-in-use':\n      return 'This email is already registered';\n    case 'auth/weak-password':\n      return 'Password should be at least 6 characters';\n    case 'auth/invalid-email':\n      return 'Invalid email address';\n    case 'auth/account-exists-with-different-credential':\n      return 'An account already exists with the same email but different sign-in credentials';\n    case 'auth/popup-closed-by-user':\n      return 'Sign-in popup was closed before completing the sign in';\n    default:\n      return 'An error occurred during authentication';\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,r.jsx)(n.p,{children:"Here's how I use the AuthContext in components:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"import { useAuth } from '../contexts/AuthContext';\n\nfunction ProfilePage() {\n  const { user, updateUserProfile, error } = useAuth();\n  const [displayName, setDisplayName] = useState(user?.displayName || '');\n  const [bio, setBio] = useState('');\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    \n    try {\n      await updateUserProfile({\n        displayName,\n        bio\n      });\n      \n      // Show success message\n    } catch (error) {\n      // Handle error\n    }\n  };\n  \n  return (\n    <div>\n      <h1>Edit Profile</h1>\n      {error && <div className=\"error\">{error}</div>}\n      <form onSubmit={handleSubmit}>\n        <div>\n          <label>Display Name</label>\n          <input\n            type=\"text\"\n            value={displayName}\n            onChange={(e) => setDisplayName(e.target.value)}\n          />\n        </div>\n        <div>\n          <label>Bio</label>\n          <textarea\n            value={bio}\n            onChange={(e) => setBio(e.target.value)}\n          />\n        </div>\n        <button type=\"submit\">Save Changes</button>\n      </form>\n    </div>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,r.jsx)(n.p,{children:"I implemented several security best practices:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Protected Routes"}),": Unauthorized users can't access protected content"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Authentication State Persistence"}),": Users stay logged in across sessions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Session Management"}),": Proper handling of login state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Handling"}),": Secure error messages that don't leak sensitive information"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'// Protected route component\nfunction PrivateRoute({ children }) {\n  const { user, loading } = useAuth();\n  const location = useLocation();\n  \n  if (loading) {\n    return <LoadingSpinner />;\n  }\n  \n  if (!user) {\n    return <Navigate to="/login" state={{ from: location }} replace />;\n  }\n  \n  return children;\n}\n\n// Usage\n<Routes>\n  <Route path="/login" element={<LoginPage />} />\n  <Route path="/signup" element={<SignupPage />} />\n  <Route \n    path="/chat/*" \n    element={\n      <PrivateRoute>\n        <ChatLayout />\n      </PrivateRoute>\n    } \n  />\n</Routes>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"challenges-and-solutions",children:"Challenges and Solutions"}),"\n",(0,r.jsx)(n.h3,{id:"challenge-1-user-presence",children:"Challenge 1: User Presence"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Accurately tracking when users are online/offline was tricky, especially with unreliable connections."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": I used Firebase's special ",(0,r.jsx)(n.code,{children:".info/connected"})," path and ",(0,r.jsx)(n.code,{children:"onDisconnect()"})," handlers to update status reliably:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// When user connects\nonValue(connectedRef, (snapshot) => {\n  if (snapshot.val() === true) {\n    // User is connected\n    const userStatusRef = ref(db, `users/${user.uid}`);\n    \n    // When this client disconnects, update the user's status\n    onDisconnect(userStatusRef).update({\n      isOnline: false,\n      lastSeen: serverTimestamp()\n    });\n    \n    // Set the user's status to online\n    update(userStatusRef, {\n      isOnline: true,\n      lastSeen: serverTimestamp()\n    });\n  }\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"challenge-2-auth-state-persistence",children:"Challenge 2: Auth State Persistence"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": I needed to decide how long users should stay logged in."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": I configured Firebase Auth persistence to balance security and convenience:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// In firebase.js config\nimport { initializeAuth, browserLocalPersistence } from 'firebase/auth';\n\n// Initialize auth with persistence\nconst auth = initializeAuth(app, {\n  persistence: [browserLocalPersistence]\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"challenge-3-race-conditions",children:"Challenge 3: Race Conditions"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Sometimes database updates would happen before the auth state was fully initialized."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": I used the loading state to prevent rendering until authentication was complete:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"return (\n  <AuthContext.Provider value={value}>\n    {!loading && children}\n  </AuthContext.Provider>\n);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,r.jsx)(n.p,{children:"I wrote tests for the AuthContext to ensure it works correctly:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// AuthContext.test.js\nimport { render, screen, act } from '@testing-library/react';\nimport { AuthProvider, useAuth } from './AuthContext';\nimport { auth } from '../config/firebase';\n\n// Mock Firebase\njest.mock('../config/firebase', () => ({\n  auth: {\n    onAuthStateChanged: jest.fn(),\n    signInWithEmailAndPassword: jest.fn(),\n    createUserWithEmailAndPassword: jest.fn(),\n    signOut: jest.fn()\n  },\n  db: {\n    ref: jest.fn(),\n    set: jest.fn(),\n    update: jest.fn(),\n    onValue: jest.fn()\n  }\n}));\n\n// Test component that uses auth context\nfunction TestComponent() {\n  const { user, login } = useAuth();\n  \n  return (\n    <div>\n      <div data-testid=\"user\">{user ? user.email : 'No user'}</div>\n      <button onClick={() => login('test@example.com', 'password')}>\n        Login\n      </button>\n    </div>\n  );\n}\n\ndescribe('AuthContext', () => {\n  beforeEach(() => {\n    // Reset mocks\n    jest.clearAllMocks();\n  });\n  \n  it('provides authentication state to components', async () => {\n    // Mock auth state change\n    auth.onAuthStateChanged.mockImplementation((callback) => {\n      callback({ uid: '123', email: 'test@example.com' });\n      return jest.fn(); // Unsubscribe function\n    });\n    \n    render(\n      <AuthProvider>\n        <TestComponent />\n      </AuthProvider>\n    );\n    \n    // Check if user is provided to component\n    expect(screen.getByTestId('user')).toHaveTextContent('test@example.com');\n  });\n  \n  // More tests...\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,r.jsx)(n.p,{children:"I have several ideas for enhancing the AuthContext in the future:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multi-factor Authentication"}),": Add an extra layer of security"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Social Logins"}),": Add more providers like Twitter, GitHub, etc."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Session Management"}),": Allow users to view and manage active sessions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Account Linking"}),": Let users link multiple auth providers to one account"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Better Error Handling"}),": More detailed error messages and recovery options"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"The AuthContext is the foundation of the chat application's security model. By centralizing authentication logic, I was able to create a consistent, secure user experience throughout the app."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);