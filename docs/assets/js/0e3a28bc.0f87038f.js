"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[7221],{1910:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>m});const o=JSON.parse('{"id":"Features/emoji-reaction-system","title":"Emoji/Reaction System","description":"Adding a robust emoji reaction system was essential to make conversations more expressive and engaging. I wanted users to be able to quickly react to messages without typing full responses, similar to popular messaging platforms.","source":"@site/docs-source/Features/emoji-reaction-system.md","sourceDirName":"Features","slug":"/Features/emoji-reaction-system","permalink":"/CustomChatApp/docs/Features/emoji-reaction-system","draft":false,"unlisted":false,"editUrl":"https://github.com/Emir2099/CustomChatApp/docs-source/Features/emoji-reaction-system.md","tags":[],"version":"current","lastUpdatedAt":1747596452000,"sidebarPosition":18,"frontMatter":{"sidebar_position":18},"sidebar":"tutorialSidebar","previous":{"title":"Chat Groups Management","permalink":"/CustomChatApp/docs/Features/chat-groups-management"},"next":{"title":"Installation & Setup","permalink":"/CustomChatApp/docs/Getting-started/installation"}}');var s=t(4848),a=t(8453);const i={sidebar_position:18},r="Emoji/Reaction System",c={},m=[{value:"Core Emoji Features",id:"core-emoji-features",level:2},{value:"Custom Emoji Management",id:"custom-emoji-management",level:2},{value:"Reaction Context",id:"reaction-context",level:2},{value:"Technical Challenges",id:"technical-challenges",level:2},{value:"Performance with Many Reactions",id:"performance-with-many-reactions",level:3},{value:"Custom Emoji Storage Optimization",id:"custom-emoji-storage-optimization",level:3},{value:"Emoji Data Synchronization",id:"emoji-data-synchronization",level:3},{value:"Future Improvements",id:"future-improvements",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"emojireaction-system",children:"Emoji/Reaction System"})}),"\n",(0,s.jsx)(n.p,{children:"Adding a robust emoji reaction system was essential to make conversations more expressive and engaging. I wanted users to be able to quickly react to messages without typing full responses, similar to popular messaging platforms."}),"\n",(0,s.jsx)(n.h2,{id:"core-emoji-features",children:"Core Emoji Features"}),"\n",(0,s.jsx)(n.p,{children:"I implemented a reaction system with multiple features:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Quick reactions to messages"}),"\n",(0,s.jsx)(n.li,{children:"Custom emoji support"}),"\n",(0,s.jsx)(n.li,{children:"Support for multiple reactions per message"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// src/components/emoji/MessageReactions.jsx\nfunction MessageReactions({ message }) {\n  const [showReactionPanel, setShowReactionPanel] = useState(false);\n  const { addReaction, removeReaction } = useChat();\n  const { currentUser } = useAuth();\n  const reactionsContainerRef = useRef(null);\n  const panelRef = useRef(null);\n  \n  // Group reactions by emoji\n  const groupedReactions = useMemo(() => {\n    if (!message.reactions) return [];\n    \n    const groups = {};\n    \n    Object.entries(message.reactions).forEach(([reactionId, reaction]) => {\n      const emojiKey = reaction.custom ? `custom:${reaction.emojiId}` : reaction.emoji;\n      \n      if (!groups[emojiKey]) {\n        groups[emojiKey] = {\n          emoji: reaction.emoji,\n          custom: reaction.custom,\n          url: reaction.url,\n          emojiId: reaction.emojiId,\n          count: 0,\n          users: [],\n          userReactionId: null // Store the reactionId if current user reacted\n        };\n      }\n      \n      groups[emojiKey].count++;\n      groups[emojiKey].users.push(reaction.userId);\n      \n      // Check if current user added this reaction\n      if (reaction.userId === currentUser?.uid) {\n        groups[emojiKey].userReactionId = reactionId;\n      }\n    });\n    \n    return Object.values(groups).sort((a, b) => b.count - a.count);\n  }, [message.reactions, currentUser]);\n  \n  // Close panel when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event) => {\n      if (\n        panelRef.current && \n        !panelRef.current.contains(event.target) && \n        !reactionsContainerRef.current.contains(event.target)\n      ) {\n        setShowReactionPanel(false);\n      }\n    };\n    \n    if (showReactionPanel) {\n      document.addEventListener('mousedown', handleClickOutside);\n    }\n    \n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [showReactionPanel]);\n  \n  // Handle adding a reaction\n  const handleAddReaction = (emoji) => {\n    addReaction(message.chatId, message.id, emoji);\n    setShowReactionPanel(false);\n  };\n  \n  // Toggle a reaction (add or remove)\n  const handleToggleReaction = (reaction) => {\n    // If user already reacted with this emoji, remove it\n    if (reaction.userReactionId) {\n      removeReaction(message.chatId, message.id, reaction.userReactionId);\n    } else {\n      // Add reaction with this emoji\n      const emoji = {\n        native: reaction.emoji,\n        custom: reaction.custom,\n        emojiId: reaction.emojiId,\n        url: reaction.url\n      };\n      \n      addReaction(message.chatId, message.id, emoji);\n    }\n  };\n  \n  return (\n    <div className={styles.reactionsContainer}>\n      {/* Grouped reactions display */}\n      <div className={styles.reactionsList}>\n        {groupedReactions.map((reaction, index) => (\n          <button\n            key={`${reaction.emoji}-${index}`}\n            className={`${styles.reactionBadge} ${\n              reaction.userReactionId ? styles.userReacted : ''\n            }`}\n            onClick={() => handleToggleReaction(reaction)}\n            title={`${reaction.count} ${reaction.count === 1 ? 'person' : 'people'}`}\n          >\n            {reaction.custom ? (\n              <img \n                src={reaction.url} \n                alt=\"\" \n                className={styles.reactionEmoji} \n              />\n            ) : (\n              <span className={styles.reactionEmoji}>{reaction.emoji}</span>\n            )}\n            <span className={styles.reactionCount}>{reaction.count}</span>\n          </button>\n        ))}\n      </div>\n      \n      {/* Add reaction button */}\n      <div \n        className={styles.addReactionContainer}\n        ref={reactionsContainerRef}\n      >\n        <button \n          className={styles.addReactionButton} \n          onClick={() => setShowReactionPanel(!showReactionPanel)}\n          aria-label=\"Add reaction\"\n        >\n          <SmileIcon className={styles.addReactionIcon} />\n        </button>\n        \n        {showReactionPanel && (\n          <div \n            className={styles.reactionPanelContainer} \n            ref={panelRef}\n          >\n            <div className={styles.reactionOptions}>\n              {/* Quick reaction options */}\n              {quickReactions.map(emoji => (\n                <button\n                  key={emoji}\n                  className={styles.reactionOption}\n                  onClick={() => handleAddReaction({ native: emoji })}\n                >\n                  {emoji}\n                </button>\n              ))}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"custom-emoji-management",children:"Custom Emoji Management"}),"\n",(0,s.jsx)(n.p,{children:"I implemented support for custom/uploaded emojis:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// src/components/emoji/CustomEmojiManager.jsx\nfunction CustomEmojiManager() {\n  const [customEmojis, setCustomEmojis] = useState([]);\n  const [isUploading, setIsUploading] = useState(false);\n  const [uploadProgress, setUploadProgress] = useState(0);\n  const [error, setError] = useState(null);\n  const [newEmojiName, setNewEmojiName] = useState(\"\");\n  const fileInputRef = useRef(null);\n  \n  const { currentUser } = useAuth();\n  const { currentChat } = useChat();\n  \n  // Load custom emojis for the current chat\n  useEffect(() => {\n    if (!currentChat?.id) return;\n    \n    const customEmojisRef = ref(db, `chatEmojis/${currentChat.id}`);\n    \n    const handleEmojisChange = (snapshot) => {\n      if (snapshot.exists()) {\n        const emojisData = snapshot.val();\n        const formattedEmojis = Object.entries(emojisData).map(([id, data]) => ({\n          id,\n          ...data\n        }));\n        \n        setCustomEmojis(formattedEmojis);\n      } else {\n        setCustomEmojis([]);\n      }\n    };\n    \n    onValue(customEmojisRef, handleEmojisChange);\n    \n    return () => off(customEmojisRef);\n  }, [currentChat?.id]);\n  \n  // Check if user can manage emojis (admin or moderator)\n  const canManageEmojis = useMemo(() => {\n    if (!currentChat || !currentUser) return false;\n    \n    // For group chats, check role\n    if (currentChat.isGroup && currentChat.groupData) {\n      const userRole = currentChat.groupData.members?.[currentUser.uid]?.role;\n      return userRole === 'admin' || userRole === 'moderator';\n    }\n    \n    // For direct chats, both users can add custom emojis\n    return true;\n  }, [currentChat, currentUser]);\n  \n  // Handle file selection\n  const handleFileSelect = (e) => {\n    const file = e.target.files[0];\n    if (!file) return;\n    \n    if (!file.type.match('image.*')) {\n      setError('Please select an image file');\n      return;\n    }\n    \n    if (file.size > 1024 * 1024) { // 1MB limit\n      setError('Image size must be under 1MB');\n      return;\n    }\n    \n    // Proceed with upload\n    handleUpload(file);\n  };\n  \n  // Upload custom emoji\n  const handleUpload = async (file) => {\n    if (!newEmojiName.trim()) {\n      setError('Please enter a name for the emoji');\n      return;\n    }\n    \n    setIsUploading(true);\n    setError(null);\n    \n    try {\n      // Create storage reference\n      const storageRef = ref(\n        storage, \n        `emojis/${currentChat.id}/${Date.now()}_${file.name}`\n      );\n      \n      // Upload file with progress tracking\n      const uploadTask = uploadBytesResumable(storageRef, file);\n      \n      uploadTask.on(\n        'state_changed',\n        (snapshot) => {\n          const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\n          setUploadProgress(progress);\n        },\n        (error) => {\n          console.error('Error uploading emoji:', error);\n          setError('Failed to upload emoji. Please try again.');\n          setIsUploading(false);\n        },\n        async () => {\n          // Upload complete\n          const downloadUrl = await getDownloadURL(uploadTask.snapshot.ref);\n          \n          // Save emoji to database\n          const emojiRef = ref(db, `chatEmojis/${currentChat.id}`);\n          const newEmojiRef = push(emojiRef);\n          \n          await set(newEmojiRef, {\n            name: newEmojiName.trim(),\n            url: downloadUrl,\n            createdBy: currentUser.uid,\n            createdAt: serverTimestamp()\n          });\n          \n          // Reset form\n          setNewEmojiName(\"\");\n          setUploadProgress(0);\n          setIsUploading(false);\n          \n          if (fileInputRef.current) {\n            fileInputRef.current.value = \"\";\n          }\n        }\n      );\n    } catch (err) {\n      console.error('Error in emoji upload:', err);\n      setError('Something went wrong. Please try again.');\n      setIsUploading(false);\n    }\n  };\n  \n  // Delete custom emoji\n  const handleDelete = async (emojiId) => {\n    if (!canManageEmojis) return;\n    \n    try {\n      // Get emoji data to delete from storage\n      const emojiRef = ref(db, `chatEmojis/${currentChat.id}/${emojiId}`);\n      const emojiSnapshot = await get(emojiRef);\n      \n      if (emojiSnapshot.exists()) {\n        const emojiData = emojiSnapshot.val();\n        \n        // Delete from database\n        await remove(emojiRef);\n        \n        // Delete from storage if possible\n        try {\n          const storageRef = ref(storage, emojiData.url);\n          await deleteObject(storageRef);\n        } catch (storageError) {\n          console.error('Error deleting emoji from storage:', storageError);\n          // Continue anyway since DB entry is removed\n        }\n      }\n    } catch (err) {\n      console.error('Error deleting custom emoji:', err);\n      setError('Failed to delete emoji');\n    }\n  };\n  \n  return (\n    <div className={styles.customEmojiManager}>\n      <h3>Custom Emojis</h3>\n      \n      {error && <div className={styles.errorMessage}>{error}</div>}\n      \n      {canManageEmojis && (\n        <div className={styles.uploadSection}>\n          <div className={styles.inputGroup}>\n            <input\n              type=\"text\"\n              placeholder=\"Emoji name\"\n              value={newEmojiName}\n              onChange={(e) => setNewEmojiName(e.target.value)}\n              className={styles.emojiNameInput}\n              disabled={isUploading}\n            />\n            \n            <input\n              type=\"file\"\n              accept=\"image/png,image/jpeg,image/gif\"\n              ref={fileInputRef}\n              onChange={handleFileSelect}\n              className={styles.fileInput}\n              disabled={isUploading}\n            />\n            \n            <button\n              className={styles.browseButton}\n              onClick={() => fileInputRef.current?.click()}\n              disabled={isUploading}\n            >\n              Browse\n            </button>\n          </div>\n          \n          {isUploading && (\n            <div className={styles.progressBar}>\n              <div \n                className={styles.progressFill}\n                style={{ width: `${uploadProgress}%` }}\n              />\n              <span className={styles.progressText}>{Math.round(uploadProgress)}%</span>\n            </div>\n          )}\n        </div>\n      )}\n      \n      <div className={styles.emojiGrid}>\n        {customEmojis.length === 0 ? (\n          <div className={styles.noEmojis}>\n            No custom emojis added yet\n          </div>\n        ) : (\n          customEmojis.map(emoji => (\n            <div key={emoji.id} className={styles.emojiItem}>\n              <img \n                src={emoji.url} \n                alt={emoji.name} \n                className={styles.emojiImage}\n              />\n              <span className={styles.emojiName}>{emoji.name}</span>\n              \n              {canManageEmojis && (\n                <button \n                  className={styles.deleteButton}\n                  onClick={() => handleDelete(emoji.id)}\n                  aria-label={`Delete ${emoji.name}`}\n                >\n                  <DeleteIcon />\n                </button>\n              )}\n            </div>\n          ))\n        )}\n      </div>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"reaction-context",children:"Reaction Context"}),"\n",(0,s.jsx)(n.p,{children:"To manage reactions throughout the application, I created dedicated methods in the chat context:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// src/contexts/ChatContext.jsx - Reaction methods\n// Add a reaction to a message\nconst addReaction = async (chatId, messageId, emoji) => {\n  if (!currentUser || !chatId || !messageId) return;\n  \n  try {\n    // Create reaction entry\n    const reactionsRef = ref(db, `messages/${chatId}/${messageId}/reactions`);\n    const newReactionRef = push(reactionsRef);\n    \n    const reactionData = formatReactionForStorage(emoji, currentUser.uid);\n    \n    await set(newReactionRef, reactionData);\n    \n    return true;\n  } catch (error) {\n    console.error("Error adding reaction:", error);\n    return false;\n  }\n};\n\n// Remove a reaction from a message\nconst removeReaction = async (chatId, messageId, reactionId) => {\n  if (!currentUser || !chatId || !messageId || !reactionId) return;\n  \n  try {\n    const reactionRef = ref(db, `messages/${chatId}/${messageId}/reactions/${reactionId}`);\n    \n    // Security check - ensure user can only remove their own reactions\n    const snapshot = await get(reactionRef);\n    \n    if (snapshot.exists()) {\n      const reactionData = snapshot.val();\n      \n      // Only allow removing if user is the reaction owner or has admin rights\n      if (reactionData.userId === currentUser.uid || isCurrentUserAdmin()) {\n        await remove(reactionRef);\n        return true;\n      }\n    }\n    \n    return false;\n  } catch (error) {\n    console.error("Error removing reaction:", error);\n    return false;\n  }\n};\n'})}),"\n",(0,s.jsx)(n.h2,{id:"technical-challenges",children:"Technical Challenges"}),"\n",(0,s.jsx)(n.h3,{id:"performance-with-many-reactions",children:"Performance with Many Reactions"}),"\n",(0,s.jsx)(n.p,{children:"When messages get many reactions, rendering can become slow:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Performance optimization for messages with lots of reactions\n// src/components/chat/MessageReactions.jsx\nfunction MessageReactions({ message }) {\n  // ... existing code ...\n  \n  // Only render the most common reactions if there are too many\n  const displayedReactions = useMemo(() => {\n    // If less than threshold, show all\n    if (groupedReactions.length <= 8) {\n      return groupedReactions;\n    }\n    \n    // Otherwise, prioritize showing reactions the user participated in\n    const userReactions = groupedReactions.filter(r => r.userReactionId);\n    const otherReactions = groupedReactions.filter(r => !r.userReactionId);\n    \n    // Sort others by popularity\n    const sortedOthers = otherReactions.sort((a, b) => b.count - a.count);\n    \n    // Combine up to 8 total reactions\n    return [...userReactions, ...sortedOthers]\n      .slice(0, 8)\n      .sort((a, b) => b.count - a.count);\n  }, [groupedReactions]);\n  \n  // Additional UI to show total reaction count when not all are displayed\n  const totalReactionCount = useMemo(() => {\n    return groupedReactions.reduce((total, reaction) => total + reaction.count, 0);\n  }, [groupedReactions]);\n  \n  const hiddenReactionCount = groupedReactions.length > 8 \n    ? totalReactionCount - displayedReactions.reduce((sum, r) => sum + r.count, 0)\n    : 0;\n  \n  // ... render using displayedReactions instead of groupedReactions ...\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"custom-emoji-storage-optimization",children:"Custom Emoji Storage Optimization"}),"\n",(0,s.jsx)(n.p,{children:"Custom emojis can consume a lot of storage space:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Optimizing custom emoji uploads\n// src/utils/imageProcessing.js\nexport const optimizeImage = async (file) => {\n  return new Promise((resolve, reject) => {\n    // Create new image element\n    const img = new Image();\n    const reader = new FileReader();\n    \n    reader.onload = (e) => {\n      img.src = e.target.result;\n      img.onload = () => {\n        // Create canvas for resizing\n        const canvas = document.createElement('canvas');\n        \n        // Max size for custom emojis (64x64)\n        const MAX_SIZE = 64;\n        \n        let width = img.width;\n        let height = img.height;\n        \n        // Maintain aspect ratio\n        if (width > height) {\n          if (width > MAX_SIZE) {\n            height = Math.round(height * MAX_SIZE / width);\n            width = MAX_SIZE;\n          }\n        } else {\n          if (height > MAX_SIZE) {\n            width = Math.round(width * MAX_SIZE / height);\n            height = MAX_SIZE;\n          }\n        }\n        \n        canvas.width = width;\n        canvas.height = height;\n        \n        // Draw resized image\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(img, 0, 0, width, height);\n        \n        // Convert to Blob\n        canvas.toBlob((blob) => {\n          if (!blob) {\n            reject(new Error('Failed to process image'));\n            return;\n          }\n          \n          // Create a new File object\n          const optimizedFile = new File([blob], file.name, {\n            type: 'image/png',\n            lastModified: Date.now()\n          });\n          \n          resolve(optimizedFile);\n        }, 'image/png', 0.8); // Use PNG for emojis with transparency\n      };\n      \n      img.onerror = () => {\n        reject(new Error('Failed to load image'));\n      };\n    };\n    \n    reader.onerror = () => {\n      reject(new Error('Failed to read file'));\n    };\n    \n    reader.readAsDataURL(file);\n  });\n};\n\n// Used in CustomEmojiManager.jsx\nconst handleFileSelect = async (e) => {\n  const file = e.target.files[0];\n  if (!file) return;\n  \n  if (!file.type.match('image.*')) {\n    setError('Please select an image file');\n    return;\n  }\n  \n  if (file.size > 2 * 1024 * 1024) { // 2MB initial limit\n    setError('Image size must be under 2MB');\n    return;\n  }\n  \n  try {\n    // Optimize the image before upload\n    const optimizedFile = await optimizeImage(file);\n    handleUpload(optimizedFile);\n  } catch (err) {\n    console.error('Error optimizing image:', err);\n    setError('Failed to process image. Please try another.');\n  }\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"emoji-data-synchronization",children:"Emoji Data Synchronization"}),"\n",(0,s.jsx)(n.p,{children:"Keeping emoji data in sync across clients was challenging:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// src/contexts/EmojiContext.jsx\nexport function EmojiProvider({ children }) {\n  const [customEmojis, setCustomEmojis] = useState({});\n  const [customEmojisByChat, setCustomEmojisByChat] = useState({});\n  const [recentEmojis, setRecentEmojis] = useState([]);\n  \n  const { currentUser } = useAuth();\n  const { userChats } = useChat();\n  \n  // Load recent emojis from local storage\n  useEffect(() => {\n    setRecentEmojis(getRecentEmojis());\n    \n    // Set up storage event listener to sync recent emojis across tabs\n    const handleStorageChange = (e) => {\n      if (e.key === 'recentEmojis') {\n        try {\n          const updatedEmojis = JSON.parse(e.newValue || '[]');\n          setRecentEmojis(updatedEmojis);\n        } catch (err) {\n          console.error('Error parsing recent emojis from storage event:', err);\n        }\n      }\n    };\n    \n    window.addEventListener('storage', handleStorageChange);\n    \n    return () => {\n      window.removeEventListener('storage', handleStorageChange);\n    };\n  }, []);\n  \n  // Load global custom emojis\n  useEffect(() => {\n    if (!currentUser) return;\n    \n    const globalEmojisRef = ref(db, 'globalEmojis');\n    \n    const handleGlobalEmojis = (snapshot) => {\n      if (snapshot.exists()) {\n        const emojisData = snapshot.val();\n        const formattedEmojis = {};\n        \n        Object.entries(emojisData).forEach(([id, data]) => {\n          formattedEmojis[id] = {\n            id,\n            ...data,\n            custom: true\n          };\n        });\n        \n        setCustomEmojis(formattedEmojis);\n      }\n    };\n    \n    onValue(globalEmojisRef, handleGlobalEmojis);\n    \n    return () => off(globalEmojisRef);\n  }, [currentUser]);\n  \n  // Load custom emojis for all user's chats\n  useEffect(() => {\n    if (!currentUser || !userChats.length) return;\n    \n    const chatEmojiRefs = {};\n    const chatEmojis = {};\n    \n    userChats.forEach(chatId => {\n      const chatEmojiRef = ref(db, `chatEmojis/${chatId}`);\n      chatEmojiRefs[chatId] = chatEmojiRef;\n      \n      onValue(chatEmojiRef, (snapshot) => {\n        if (snapshot.exists()) {\n          const emojisData = snapshot.val();\n          const formattedEmojis = {};\n          \n          Object.entries(emojisData).forEach(([id, data]) => {\n            formattedEmojis[id] = {\n              id,\n              ...data,\n              custom: true,\n              chatId\n            };\n          });\n          \n          chatEmojis[chatId] = formattedEmojis;\n          setCustomEmojisByChat({...chatEmojis});\n        } else {\n          chatEmojis[chatId] = {};\n          setCustomEmojisByChat({...chatEmojis});\n        }\n      });\n    });\n    \n    return () => {\n      Object.values(chatEmojiRefs).forEach(ref => off(ref));\n    };\n  }, [currentUser, userChats]);\n  \n  return (\n    <EmojiContext.Provider value={{\n      recentEmojis,\n      customEmojis,\n      customEmojisByChat,\n      getCustomEmojiById: (id) => customEmojis[id] || null,\n      getChatEmojis: (chatId) => customEmojisByChat[chatId] || {},\n      getAllAvailableEmojis: (chatId) => {\n        // Combine global and chat-specific emojis\n        return {\n          ...customEmojis,\n          ...(customEmojisByChat[chatId] || {})\n        };\n      }\n    }}>\n      {children}\n    </EmojiContext.Provider>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,s.jsx)(n.p,{children:"I have several ideas to enhance the emoji and reaction system:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Emoji Categories"})," - Allow users to organize custom emojis into categories."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Reaction Analytics"})," - Show which emojis are most popular in different chats."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Animated Emoji Support"})," - Add support for animated GIFs as custom emojis."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Emoji Pack Importing"})," - Allow importing sets of custom emojis all at once."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Reaction Highlights"})," - Highlight messages that receive many reactions."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The emoji reaction system has been a hit with users, making conversations more dynamic and expressive. It's especially popular in group chats where quick reactions are often preferred over typing full responses."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var o=t(6540);const s={},a=o.createContext(s);function i(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);